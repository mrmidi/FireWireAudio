=== include/shared/SharedMemoryStructures.hpp ===
// SharedMemoryStructures.hpp (refactored)
#pragma once
#include <CoreAudio/AudioServerPlugIn.h>
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <cstring>

constexpr std::size_t kDestructiveCL     = 64;
constexpr std::size_t kMaxFramesPerChunk = 512;
constexpr std::size_t kMaxChannels       = 2;
constexpr std::size_t kMaxBytesPerSample = 4;
constexpr std::size_t kMaxBytesPerFrame  = kMaxChannels * kMaxBytesPerSample;
constexpr std::size_t kRingCapacityPow2  = 128; // TEST
static_assert((kRingCapacityPow2 & (kRingCapacityPow2 - 1)) == 0);
constexpr std::size_t kAudioDataBytes = kMaxFramesPerChunk * kMaxBytesPerFrame;
constexpr uint32_t    kShmVersion     = 3;

namespace RTShmRing {

// --- POD Structures ---

struct alignas(kDestructiveCL) AudioChunk_POD {
    AudioTimeStamp timeStamp{};
    uint32_t       frameCount{0};
    uint32_t       dataBytes{0};
    uint64_t       sequence{0};
    std::byte      audio[kAudioDataBytes]{};
};
// static_assert(sizeof(AudioChunk_POD) <= 4096);
static_assert(sizeof(AudioChunk_POD) % kDestructiveCL == 0);




// struct alignas(kDestructiveCL) ControlBlock_POD {
//     uint32_t abiVersion;      // = 2
//     uint32_t capacity;        // ring length
//     uint32_t sampleRateHz;    // e.g. 44100
//     uint32_t channelCount;    // e.g. 2
//     uint32_t bytesPerFrame;   // = channelCount * bytesPerSample
//     uint64_t writeIndex;
//     char     pad0[kDestructiveCL
//                    - sizeof(uint32_t)*5
//                    - sizeof(uint64_t)];
//     uint64_t readIndex;
//     char     pad1[kDestructiveCL - sizeof(uint64_t)];
//     uint32_t overrunCount;
//     uint32_t underrunCount;
//     uint32_t streamActive;    // 0 = idle, 1 = running
//     uint32_t reserved;        // keep 64-byte alignment
// };

struct alignas(kDestructiveCL) ControlBlock_POD {
    uint32_t abiVersion;      // 0
    uint32_t capacity;        // 4
    uint32_t sampleRateHz;    // 8
    uint32_t channelCount;    // 12
    uint32_t bytesPerFrame;   // 16
    uint32_t _padWriteAlign;  // 20 - NEW: explicit padding
    uint64_t writeIndex;      // 24 - now 8-byte aligned
    char     pad0[kDestructiveCL - 6*sizeof(uint32_t) - sizeof(uint64_t)];
    uint64_t readIndex;       // Already aligned due to cache line boundary
    char     pad1[kDestructiveCL - sizeof(uint64_t)];
    uint32_t overrunCount;
    uint32_t underrunCount;
    uint32_t streamActive;
    uint32_t reserved;
};

// Add compile-time verification
static_assert(offsetof(ControlBlock_POD, writeIndex) % 8 == 0, "writeIndex must be 8-byte aligned");
static_assert(offsetof(ControlBlock_POD, readIndex) % 8 == 0, "readIndex must be 8-byte aligned");


static_assert(sizeof(ControlBlock_POD) % kDestructiveCL == 0);

struct alignas(kDestructiveCL) SharedRingBuffer_POD
{
    ControlBlock_POD control;
    AudioChunk_POD   ring[kRingCapacityPow2];
};

// --- Format Validation Helpers ---
inline bool ValidateFormat(const ControlBlock_POD& cb) noexcept {
    if (cb.abiVersion != kShmVersion) return false;
    if (cb.sampleRateHz == 0 || cb.channelCount == 0) return false;
    if (cb.channelCount > kMaxChannels) return false;
    if (cb.bytesPerFrame != cb.channelCount * kMaxBytesPerSample) return false;
    
    // NEW: Validate capacity is power-of-two and reasonable
    if (cb.capacity == 0) return false;
    if ((cb.capacity & (cb.capacity - 1)) != 0) return false;  // Must be power of 2
    if (cb.capacity > 65536) return false;  // Reasonable upper limit
    
    return true;
}

// --- Atomic Proxies ---
inline std::atomic<uint64_t>& WriteIndexProxy(ControlBlock_POD& cb) noexcept {
    return *reinterpret_cast<std::atomic<uint64_t>*>(&cb.writeIndex);
}
inline std::atomic<uint64_t>& ReadIndexProxy(ControlBlock_POD& cb) noexcept {
    return *reinterpret_cast<std::atomic<uint64_t>*>(&cb.readIndex);
}
inline std::atomic<uint64_t>& SequenceProxy(AudioChunk_POD& c) noexcept {
    return *reinterpret_cast<std::atomic<uint64_t>*>(&c.sequence);
}
inline std::atomic<uint32_t>& OverrunCountProxy(ControlBlock_POD& cb) noexcept {
    return *reinterpret_cast<std::atomic<uint32_t>*>(&cb.overrunCount);
}
inline std::atomic<uint32_t>& UnderrunCountProxy(ControlBlock_POD& cb) noexcept {
    return *reinterpret_cast<std::atomic<uint32_t>*>(&cb.underrunCount);
}

// --- push → unchanged except format check ---
inline bool push(ControlBlock_POD&       cb,
                 AudioChunk_POD*         ring,
                 const AudioBufferList*  src,
                 const AudioTimeStamp&   ts,
                 uint32_t                frames,
                 uint32_t                bpf) noexcept
{
    if (!ValidateFormat(cb)) return false;
    if (!src || !ring || frames==0 || frames>kMaxFramesPerChunk) return false;
    auto rd = ReadIndexProxy(cb).load(std::memory_order_acquire);
    auto wr = WriteIndexProxy(cb).load(std::memory_order_relaxed);
    if (wr - rd >= cb.capacity) return false;

    auto slot = wr & (cb.capacity-1);
    auto& c   = ring[slot];
    auto totalBytes = frames * bpf;
    if (totalBytes > kAudioDataBytes) return false;

    c.timeStamp  = ts;
    c.frameCount = frames;
    c.dataBytes  = totalBytes;

    auto dst = c.audio;
    for (UInt32 i=0; i<src->mNumberBuffers; ++i) {
        auto& b = src->mBuffers[i];
        if (!b.mData || b.mDataByteSize==0)
            std::memset(dst,0,b.mDataByteSize);
        else
            std::memcpy(dst,b.mData,b.mDataByteSize);
        dst += b.mDataByteSize;
    }

    std::atomic_thread_fence(std::memory_order_release);
    SequenceProxy(c).store(wr+1, std::memory_order_relaxed);
    WriteIndexProxy(cb).store(wr+1, std::memory_order_release);
    return true;
}

// --- zero-copy pop → new API for packet provider ---
// FIXED pop() function - remove const parameters to avoid const_cast
inline bool pop(ControlBlock_POD&       cb,           // CHANGED: remove const
                AudioChunk_POD*         ring,         // CHANGED: remove const  
                AudioTimeStamp&         tsOut,
                uint32_t&               bytesOut,
                const std::byte*&       audioPtrOut) noexcept
{
    if (!ValidateFormat(cb)) return false;

    static thread_local bool inUnderrun = false;

    
    // CRITICAL FIX: Use WriteIndexProxy for wr, not ReadIndexProxy!
    const uint64_t wr = WriteIndexProxy(cb).load(std::memory_order_acquire);
    const uint64_t rd = ReadIndexProxy(cb).load(std::memory_order_relaxed);
    if (rd == wr) {
        // only bump once per contiguous underrun run
        if (!inUnderrun) {
            UnderrunCountProxy(cb).fetch_add(1, std::memory_order_relaxed);
            inUnderrun = true;
        }
        return false;
    }
    inUnderrun = false;            // we have data again

    const uint64_t slot = rd & (cb.capacity - 1);
    AudioChunk_POD& c = ring[slot];
    
    if (SequenceProxy(c).load(std::memory_order_acquire) != rd + 1)
        return false;

    tsOut       = c.timeStamp;
    bytesOut    = c.dataBytes;
    audioPtrOut = c.audio;

    ReadIndexProxy(cb).store(rd + 1, std::memory_order_release);
    return true;
}

} // namespace RTShmRing


=== include/Isoch/core/AmdtpTransmitter.hpp ===
#pragma once

#include <memory>
#include <expected>
#include <atomic>
#include <mutex>
#include <vector>
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <spdlog/logger.h>

#include "FWA/Error.h"
#include "Isoch/core/TransmitterTypes.hpp"
#include "Isoch/interfaces/ITransmitBufferManager.hpp"
#include "Isoch/interfaces/ITransmitDCLManager.hpp"
#include "Isoch/interfaces/ITransmitPacketProvider.hpp"

// Forward declarations
namespace FWA {
namespace Isoch {
class IsochPortChannelManager; 
class IsochTransportManager; 
} }

namespace FWA {
namespace Isoch {

class AmdtpTransmitter : public std::enable_shared_from_this<AmdtpTransmitter> {
public:
    // Factory method
    static std::shared_ptr<AmdtpTransmitter> create(const TransmitterConfig& config);

    ~AmdtpTransmitter();

    // Prevent copy
    AmdtpTransmitter(const AmdtpTransmitter&) = delete;
    AmdtpTransmitter& operator=(const AmdtpTransmitter&) = delete;

    // Core lifecycle methods
    std::expected<void, IOKitError> initialize(IOFireWireLibNubRef interface);
    std::expected<void, IOKitError> configure(IOFWSpeed speed, uint32_t channel);
    std::expected<void, IOKitError> startTransmit();
    std::expected<void, IOKitError> stopTransmit();

    // Method for client to push data into the transmitter's provider
    bool pushAudioData(const void* buffer, size_t bufferSizeInBytes);

    // Set message callback
    void setMessageCallback(MessageCallback callback, void* refCon);

    // Get underlying runloop
    CFRunLoopRef getRunLoopRef() const { return runLoopRef_; }

    ITransmitPacketProvider* getPacketProvider() const;

    inline PreparedPacketData safeFillAudio(uint8_t* dst, size_t len,
                                                         const TransmitPacketInfo& inf);


private:

        // --- LOGGING/DIAGNOSTICS ---
    std::atomic<uint64_t> dataPacketsSent_{0};
    std::atomic<uint64_t> noDataPacketsSent_{0};

    // We’ll also keep a timestamp so we only log once per second:
    std::chrono::steady_clock::time_point lastPacketLogTime_{ std::chrono::steady_clock::now() };

    // Private constructor for factory
    explicit AmdtpTransmitter(const TransmitterConfig& config);

    // Setup and cleanup
    std::expected<void, IOKitError> setupComponents(IOFireWireLibNubRef interface);
    void cleanup() noexcept;

    // Internal DCL callback handlers (instance methods)
    void handleDCLComplete(uint32_t completedGroupIndex);
    void handleDCLOverrun();

    // Static callback helpers (forward to instance methods)
    static void DCLCompleteCallback_Helper(uint32_t completedGroupIndex, void* refCon);
    static void DCLOverrunCallback_Helper(void* refCon);
    static void TransportFinalize_Helper(void* refCon); // If needed

     // CIP Header/Timing generation logic
     void initializeCIPState();
     void generateCIPHeaderContent(CIPHeader* outHeader,
                                   uint8_t current_dbc_state,
                                   bool previous_wasNoData_state,
                                   bool first_dcl_callback_occurred_state,
                                   uint8_t& next_dbc_for_state,
                                   bool& next_wasNoData_for_state);

     // --- Helper for the "Blocking" (UniversalTransmitter-style) SYT logic ---
     struct BlockingSytParams {
         bool isNoData;
         uint16_t syt_value;
     };
     BlockingSytParams calculateBlockingSyt();

     // --- Helper for the "NonBlocking" (current AmdtpTransmitter) SYT logic ---
     struct NonBlockingSytParams {
         bool isNoData;
         uint16_t syt_value;
         // Potentially other outputs specific to this strategy's state updates
     };
     NonBlockingSytParams calculateNonBlockingSyt(uint8_t current_dbc_state, bool previous_wasNoData_state);

    // Helper to send messages to the client
    void notifyMessage(TransmitterMessage msg, uint32_t p1 = 0, uint32_t p2 = 0);

    // Configuration & Logger
    TransmitterConfig config_;
    std::shared_ptr<spdlog::logger> logger_;

    // Manager Components
    std::unique_ptr<ITransmitBufferManager> bufferManager_;
    std::unique_ptr<IsochPortChannelManager> portChannelManager_; // Reusable
    std::unique_ptr<ITransmitDCLManager> dclManager_;
    std::unique_ptr<IsochTransportManager> transportManager_;     // Reusable
    std::unique_ptr<ITransmitPacketProvider> packetProvider_;

    // RunLoop
    CFRunLoopRef runLoopRef_{nullptr};

    // State
    std::atomic<bool> initialized_{false};
    std::atomic<bool> running_{false};
    std::mutex stateMutex_;

     // CIP Header State
     uint8_t dbc_count_{0};
     bool wasNoData_{true}; // Start assuming previous was NoData
     uint16_t sytOffset_{0};
     uint32_t sytPhase_{0}; // For 44.1kHz calculation
     std::atomic<bool> firstDCLCallbackOccurred_{false};
     uint32_t expectedTimeStampCycle_{0}; // For timestamp checking

    // --- NEW: State variables specifically for "Blocking" (UniversalTransmitter-style) SYT ---
    uint16_t sytOffset_blocking_{TICKS_PER_CYCLE};
    uint32_t sytPhase_blocking_{0};

    // --- Constants for "Blocking" SYT (distinct from NonBlocking) ---
    static constexpr uint32_t SYT_PHASE_MOD_BLOCKING = 147;
    static constexpr uint32_t SYT_PHASE_RESET_BLOCKING = 147;
    // static constexpr uint32_t BASE_TICKS_BLOCKING = 1386;
    static constexpr uint32_t BASE_TICKS_BLOCKING = 565;
    // TICKS_PER_CYCLE is already defined

    // Client Callbacks
    MessageCallback messageCallback_{nullptr};
    void* messageCallbackRefCon_{nullptr};

    // Interface
    IOFireWireLibNubRef interface_{nullptr}; // The FireWire nub interface

    // Static constants for SYT calc (44.1kHz)
    static constexpr uint32_t SYT_PHASE_MOD = 147;
    static constexpr uint32_t SYT_PHASE_RESET = 1470;
    static constexpr uint32_t BASE_TICKS = 1386; // ~1/8 of TICKS_PER_CYCLE
    static constexpr uint32_t TICKS_PER_CYCLE = 3072;
};

} // namespace Isoch
} // namespace FWA



=== include/Isoch/core/IsochPacketProvider.hpp ===
// IsochPacketProvider.hpp - Direct SHM Implementation
#pragma once

#include "Isoch/interfaces/ITransmitPacketProvider.hpp"
#include "shared/SharedMemoryStructures.hpp"
#include <atomic>
#include <chrono>
#include <spdlog/spdlog.h>

namespace FWA {
namespace Isoch {

class IsochPacketProvider : public ITransmitPacketProvider {
private:
    mutable std::mutex bindMutex_;  // Protect bind/unbind operations
public:
    explicit IsochPacketProvider(std::shared_ptr<spdlog::logger> logger);
    ~IsochPacketProvider() override;

    // Prevent Copy
    IsochPacketProvider(const IsochPacketProvider&) = delete;
    IsochPacketProvider& operator=(const IsochPacketProvider&) = delete;

    // --- NEW: Direct SHM Binding Interface ---
    bool bindSharedMemory(RTShmRing::ControlBlock_POD* controlBlock,
                          RTShmRing::AudioChunk_POD* ringArray);
    void unbindSharedMemory();
    bool isBound() const { return shmControlBlock_ != nullptr; }

    // --- ITransmitPacketProvider Interface ---
    bool pushAudioData(const void* buffer, size_t bufferSizeInBytes) override;
    
    PreparedPacketData fillPacketData(
        uint8_t* targetBuffer,
        size_t targetBufferSize,
        const TransmitPacketInfo& info
    ) override;

    bool isReadyForStreaming() const override;
    void reset() override;

    // --- Enhanced Diagnostics ---
    struct DiagnosticStats {
        uint64_t totalBytesConsumed;
        uint64_t shmPopCount;
        uint64_t shmUnderrunCount;
        uint64_t formatValidationErrors;
        uint64_t partialChunkConsumptions;
        double avgFillPacketDurationUs;
        uint32_t currentShmFillPercent;
    };
    
    DiagnosticStats getDiagnostics() const;
    void resetDiagnostics();

private:

    // --- SHM Cursor State ---
    RTShmRing::ControlBlock_POD* shmControlBlock_ {nullptr};
    RTShmRing::AudioChunk_POD*   shmRingArray_    {nullptr};
    
    // Current chunk cache to minimize SHM access
    struct ChunkCache {
        AudioTimeStamp timeStamp;
        uint32_t totalBytes;
        const std::byte* audioDataPtr;
        uint32_t consumedBytes;
        bool valid;
        
        void invalidate() { valid = false; consumedBytes = 0; audioDataPtr = nullptr; }
        uint32_t remainingBytes() const { return valid ? (totalBytes - consumedBytes) : 0; }
    } currentChunk_;

    // --- Core Components ---
    std::shared_ptr<spdlog::logger> logger_;
    
    // --- Diagnostics & State ---
    mutable std::atomic<uint64_t> totalBytesConsumed_{0};
    mutable std::atomic<uint64_t> shmPopCount_{0};
    mutable std::atomic<uint64_t> shmUnderrunCount_{0};
    mutable std::atomic<uint64_t> formatValidationErrors_{0};
    mutable std::atomic<uint64_t> partialChunkConsumptions_{0};
    
    // Performance timing
    mutable std::chrono::steady_clock::time_point lastStatsTime_;
    mutable std::atomic<uint64_t> fillPacketCallCount_{0};
    mutable std::atomic<uint64_t> totalFillPacketTimeNs_{0};

    // Configuration/Constants
    static constexpr uint32_t AM824_LABEL = 0x40;     // 24-bit audio label
    static constexpr uint32_t LABEL_SHIFT = 24;       // Shift for 24-bit label
    static constexpr size_t INITIAL_FILL_TARGET_PERCENT = 25;

    // --- Helper Methods ---
    bool popNextChunk();
    void handleUnderrun(const TransmitPacketInfo& info);
    void formatToAM824InPlace(uint8_t* buffer, size_t bufferSize) const;
    uint32_t getCurrentShmFillLevel() const;
    bool validateShmFormat() const;
};

} // namespace Isoch
} // namespace FWA


=== include/Isoch/utils/TimingUtils.hpp ===
// include/FWA/Isoch/utils/TimingUtils.hpp
#pragma once

#include <cstdint>           // uint32_t, uint64_t, int64_t
#include <mach/mach_time.h>  // mach_timebase_info, mach_absolute_time()

// Uncomment in CMakeLists if __int128 is available and desired:
// add_definitions(-DFWA_USE_INT128)

namespace FWA {
namespace Isoch {
namespace Timing {

//-----------------------------------------------------------------------------
// 0. Host timebase (macOS only)
//-----------------------------------------------------------------------------
// We cache the mach_timebase_info so we can convert between mach_absolute_time()
// ticks and wall-clock nanoseconds. Must call once during init.
inline mach_timebase_info_data_t gHostTimebaseInfo = {0, 0};

/**
 * @brief Query and cache the host timebase info.
 * 
 * macOS provides mach_absolute_time() in arbitrary ticks. To convert to
 * nanoseconds, we need the ratio numer/denom. This must be done once,
 * preferably in single-threaded startup.
 * 
 * @return true on success, false if the system call failed.
 */
inline bool initializeHostTimebase() {
    if (gHostTimebaseInfo.denom == 0) {
        // Only ask once
        kern_return_t kr = mach_timebase_info(&gHostTimebaseInfo);
        // Success if denom non-zero and call succeeded
        return (kr == KERN_SUCCESS && gHostTimebaseInfo.denom != 0);
    }
    return true;
}

//-----------------------------------------------------------------------------
// 1. FireWire cycle-time format (IEC 61883-6)
//-----------------------------------------------------------------------------
// FireWire divides time into 1/8000 s cycles, each cycle into 3072 offsets.
// The hardware exposes a 32-bit register with:
//   bits 25–31: seconds (0–127, wraps every 128 s)
//   bits 12–24: cycle index within the second (0–7999)
//   bits  0–11: offset within the cycle (0–3071)

/// Bus rate: 8 000 cycles per second (125 µs per cycle)
constexpr uint32_t kCyclesPerSecond    = 8000;
/// Offsets per cycle: 3 072 offsets → ~40.69 ns per offset
constexpr uint32_t kOffsetsPerCycle    = 3072;
/// Total offsets per second = 8000 × 3072 = 24 576 000
constexpr uint64_t kOffsetsPerSecond   = uint64_t(kCyclesPerSecond) * kOffsetsPerCycle;

/// Nanoseconds per second
constexpr uint64_t kNanosPerSecond     = 1'000'000'000ULL;
/// Nanoseconds per FireWire cycle: 1 000 000 000 / 8000 = 125 000 ns = 125 µs
constexpr uint64_t kNanosPerCycle      = kNanosPerSecond / kCyclesPerSecond;

/// Wraparound period: 128 seconds (per IEEE 1394-TA Spec)
constexpr uint32_t kFWTimeWrapSeconds  = 128;
constexpr uint64_t kFWTimeWrapNanos    = uint64_t(kFWTimeWrapSeconds) * kNanosPerSecond;
constexpr uint64_t kFWTimeWrapCycles   = uint64_t(kFWTimeWrapSeconds) * kCyclesPerSecond;

// Masks and shifts to extract each field from the 32-bit register
constexpr uint32_t kEncSecondsMask     = 0xFE000000; // bits 25–31
constexpr uint32_t kEncSecondsShift    = 25;
constexpr uint32_t kEncCyclesMask      = 0x01FFF000; // bits 12–24
constexpr uint32_t kEncCyclesShift     = 12;
constexpr uint32_t kEncOffsetsMask     = 0x00000FFF; // bits 0–11

//-----------------------------------------------------------------------------
// 2. Encoded ↔︎ Nanoseconds conversions
//-----------------------------------------------------------------------------

/**
 * @brief Decode a 32-bit FireWire cycle time into total nanoseconds.
 * 
 * Steps:
 *   1. Extract seconds, cycles, and offsets fields.
 *   2. Combine into a single 64-bit offset count: 
 *        totalOffsets = seconds*OFFSETS_PER_SECOND
 *                     + cycles*OFFSETS_PER_CYCLE
 *                     + offsets.
 *   3. Convert offsets → nanoseconds via:
 *        (totalOffsets / OFFSETS_PER_SECOND) * 1e9
 *      plus fractional leftover.
 * 
 * @param enc 32-bit encoded FireWire cycle time.
 * @return 64-bit nanoseconds since some wrap-epoch.
 */
inline uint64_t encodedFWTimeToNanos(uint32_t enc) noexcept {
    uint32_t sec     = (enc & kEncSecondsMask) >> kEncSecondsShift;
    uint32_t cyc     = (enc & kEncCyclesMask)  >> kEncCyclesShift;
    uint32_t offs    =  enc & kEncOffsetsMask;

    // Total offset ticks
    uint64_t totalOff = uint64_t(sec) * kOffsetsPerSecond
                      + uint64_t(cyc) * kOffsetsPerCycle
                      + offs;

#ifdef FWA_USE_INT128
    // Multiply totalOff * 1e9 (ns) using 128-bit accumulator, then divide by offsets/sec
    __uint128_t tmp = __uint128_t(totalOff) * kNanosPerSecond;
    return uint64_t(tmp / kOffsetsPerSecond);
#else
    // Split integer and fractional division
    uint64_t fullSecs      = (totalOff / kOffsetsPerSecond) * kNanosPerSecond;
    uint64_t remOffsets    = totalOff % kOffsetsPerSecond;
    uint64_t fracNs        = (remOffsets * kNanosPerSecond) / kOffsetsPerSecond;
    return fullSecs + fracNs;
#endif
}

/**
 * @brief Encode a nanosecond timestamp into 32-bit FireWire cycle time.
 * 
 * Steps:
 *   1. Wrap input nanos to [0, 128 s) via modulo.
 *   2. Compute total offset ticks = nanos * OFFSETS_PER_SECOND / 1e9.
 *   3. Split into sec, cycles, offsets fields.
 *   4. Pack into 32 bits: (sec<<25)|(cyc<<12)|offs.
 * 
 * @param nanos Absolute time in nanoseconds.
 * @return 32-bit encoded FireWire cycle time.
 */
inline uint32_t nanosToEncodedFWTime(uint64_t nanos) noexcept {
    // Wrap every 128 seconds
    uint64_t nsWrapped = nanos % kFWTimeWrapNanos;

#ifdef FWA_USE_INT128
    __uint128_t tmp = __uint128_t(nsWrapped) * kOffsetsPerSecond;
    uint64_t totalOff = uint64_t(tmp / kNanosPerSecond);
#else
    uint64_t fullOff = (nsWrapped / kNanosPerSecond) * kOffsetsPerSecond;
    uint64_t remNs   = nsWrapped % kNanosPerSecond;
    uint64_t partOff = (remNs * kOffsetsPerSecond) / kNanosPerSecond;
    uint64_t totalOff = fullOff + partOff;
#endif

    uint32_t sec  = uint32_t(totalOff / kOffsetsPerSecond) & 0x7F;
    uint32_t rem  = uint32_t(totalOff % kOffsetsPerSecond);
    uint32_t cyc  = rem / kOffsetsPerCycle;
    uint32_t offs = rem % kOffsetsPerCycle;

    return (sec << kEncSecondsShift)
         | (cyc << kEncCyclesShift)
         | offs;
}

/**
 * @brief Compute the signed nanosecond delta between two encoded FireWire times.
 * 
 * Because the 32-bit counter wraps every 128 s, we:
 *   1. Decode each to nanoseconds.
 *   2. Subtract to get raw diff.
 *   3. If |diff| > 64 s, adjust by ±128 s to pick the shortest path across wrap.
 * 
 * @param a Encoded time A.
 * @param b Encoded time B.
 * @return Signed delta in nanoseconds (A − B), minimal magnitude across wrap.
 */
inline int64_t deltaFWTimeNano(uint32_t a, uint32_t b) noexcept {
    int64_t na = int64_t(encodedFWTimeToNanos(a));
    int64_t nb = int64_t(encodedFWTimeToNanos(b));
    int64_t d  = na - nb;

    constexpr int64_t halfWrap = int64_t(kFWTimeWrapNanos / 2);
    if (d >  halfWrap) d -= int64_t(kFWTimeWrapNanos);
    if (d < -halfWrap) d += int64_t(kFWTimeWrapNanos);
    return d;
}

//-----------------------------------------------------------------------------
// 3. Host time conversions
//-----------------------------------------------------------------------------

/**
 * @brief Convert mach_absolute_time() ticks → nanoseconds.
 * @pre  initializeHostTimebase() returns true.
 * 
 * Uses timebase_info.numer/denom:
 *   ns = ticks * numer / denom
 * 
 * @param ticks Raw mach_absolute_time() value.
 * @return Nanoseconds since boot, or 0 if timebase not inited.
 */
inline uint64_t hostTicksToNanos(uint64_t ticks) noexcept {
    if (gHostTimebaseInfo.denom == 0) {
        return 0; // Not initialized
    }
#ifdef FWA_USE_INT128
    __uint128_t tmp = __uint128_t(ticks) * gHostTimebaseInfo.numer;
    return uint64_t(tmp / gHostTimebaseInfo.denom);
#else
    // Split 64-bit multiply to avoid overflow
    uint64_t hi = (ticks >> 32) * gHostTimebaseInfo.numer;
    uint64_t lo = (ticks & 0xFFFFFFFFULL) * gHostTimebaseInfo.numer;
    uint64_t combined = (hi << 32) + lo;
    return combined / gHostTimebaseInfo.denom;
#endif
}

/**
 * @brief Convert nanoseconds → mach_absolute_time() ticks.
 * @pre  initializeHostTimebase() returns true.
 * 
 * Inverse of hostTicksToNanos: ticks = nanos * denom / numer.
 */
inline uint64_t nanosToHostTicks(uint64_t nanos) noexcept {
    if (gHostTimebaseInfo.numer == 0) {
        return 0;
    }
#ifdef FWA_USE_INT128
    __uint128_t tmp = __uint128_t(nanos) * gHostTimebaseInfo.denom;
    return uint64_t(tmp / gHostTimebaseInfo.numer);
#else
    uint64_t hi = (nanos >> 32) * gHostTimebaseInfo.denom;
    uint64_t lo = (nanos & 0xFFFFFFFFULL) * gHostTimebaseInfo.denom;
    uint64_t combined = (hi << 32) + lo;
    return combined / gHostTimebaseInfo.numer;
#endif
}

} // namespace Timing
} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochPacketProvider.cpp ===
// IsochPacketProvider.cpp - Direct SHM Implementation
#include "Isoch/core/IsochPacketProvider.hpp"
#include <CoreServices/CoreServices.h>
#include <cstring>
#include <algorithm>

namespace FWA {
namespace Isoch {

IsochPacketProvider::IsochPacketProvider(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger))
{
    if (!logger_) {
        logger_ = spdlog::default_logger();
    }
    
    currentChunk_.invalidate();
    lastStatsTime_ = std::chrono::steady_clock::now();
    
    if (logger_) {
        logger_->debug("IsochPacketProvider created in direct SHM mode");
    }
    
    reset();
}

IsochPacketProvider::~IsochPacketProvider() {
    unbindSharedMemory();
    if (logger_) {
        logger_->debug("IsochPacketProvider destroyed");
    }
}

bool IsochPacketProvider::bindSharedMemory(RTShmRing::ControlBlock_POD* controlBlock,
                                           RTShmRing::AudioChunk_POD* ringArray) {
    std::lock_guard<std::mutex> lock(bindMutex_);  // Thread safety

    if (!controlBlock || !ringArray) {
        if (logger_) {
            logger_->error("bindSharedMemory: Invalid parameters (null pointers)");
        }
        return false;
    }
    
    // Validate SHM format before binding
    if (!RTShmRing::ValidateFormat(*controlBlock)) {
        formatValidationErrors_++;
        if (logger_) {
            logger_->error("bindSharedMemory: SHM format validation failed - ABI: {}, sampleRate: {}, channels: {}, bytesPerFrame: {}",
                          controlBlock->abiVersion, controlBlock->sampleRateHz, 
                          controlBlock->channelCount, controlBlock->bytesPerFrame);
        }
        return false;
    }
    
    // Unbind any existing SHM first
    if (shmControlBlock_) {
        unbindSharedMemory();
    }
    
    shmControlBlock_ = controlBlock;
    shmRingArray_ = ringArray;
    
    // *** Reset indices for a clean start ***
    RTShmRing::WriteIndexProxy(*controlBlock).store(0, std::memory_order_relaxed);
    RTShmRing::ReadIndexProxy(*controlBlock).store(0, std::memory_order_relaxed);
    
    controlBlock->streamActive = 0;        // stays idle until startAudioStreams()
    
    // Clear any leftover chunk-cache or stats
    currentChunk_.invalidate();
    reset();  // Reset bytesConsumed_, popCount_, etc. for fresh state
    
    if (logger_) {
        logger_->info("SHM bound successfully: {} Hz, {} channels, {} bytes/frame, capacity: {}",
                     controlBlock->sampleRateHz, controlBlock->channelCount, 
                     controlBlock->bytesPerFrame, controlBlock->capacity);
    }
    
    return true;
}

void IsochPacketProvider::unbindSharedMemory() {
    std::lock_guard<std::mutex> lock(bindMutex_);  // Thread safety
    if (shmControlBlock_) {
        if (logger_) {
            logger_->debug("Unbinding shared memory");
        }
        shmControlBlock_ = nullptr;
        shmRingArray_ = nullptr;
        currentChunk_.invalidate();
    }
}

// Legacy interface - not used in direct SHM mode
bool IsochPacketProvider::pushAudioData(const void* buffer, size_t bufferSizeInBytes) {
    if (logger_) {
        logger_->warn("pushAudioData called in direct SHM mode - operation not supported");
    }
    return false;
}

PreparedPacketData IsochPacketProvider::fillPacketData(
    uint8_t* targetBuffer,
    size_t targetBufferSize,
    const TransmitPacketInfo& info)
{
    // static thread_local bool inUnderrun = false;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    PreparedPacketData result;
    result.dataPtr       = targetBuffer;
    result.dataLength    = 0;
    result.generatedSilence = true;

    // === 0. Early parameter checks ===
    if (!targetBuffer || targetBufferSize == 0) {
        if (logger_) {
            logger_->error("fillPacketData: Invalid target buffer or size");
        }
        return result;
    }

    // === 1. Check for any underruns logged in SHM and clear the counter ===
    if (shmControlBlock_) {
        // Atomically read & clear the underrun counter
        uint32_t underruns = RTShmRing::UnderrunCountProxy(*shmControlBlock_)
                                .exchange(0, std::memory_order_relaxed);
        if (underruns && logger_) {
            // silence for now - too much noise
//            logger_->warn("Audio underrun x{}", underruns);
        }
    }

    // === 2. Check SHM binding ===
    if (!shmControlBlock_ || !shmRingArray_) {
        if (logger_) {
            logger_->error("fillPacketData: SHM not bound; filling silence");
        }
        std::memset(targetBuffer, 0, targetBufferSize);
        result.dataLength = targetBufferSize;
        return result;
    }

    // === 3. Validate SHM format once in a while ===
    if (!validateShmFormat()) {
        formatValidationErrors_++;
        if (logger_) {
            logger_->error("fillPacketData: SHM format invalid; filling silence");
        }
        std::memset(targetBuffer, 0, targetBufferSize);
        result.dataLength = targetBufferSize;
        return result;
    }

    // === 4. Copy from SHM ring into targetBuffer ===
    uint8_t* writePtr = targetBuffer;
    size_t   remaining = targetBufferSize;
    bool     gotAllData = true;

    // Optional periodic stats logging
    static thread_local uint32_t statsTicks = 0;
    if (++statsTicks == 8000) { // ~1 s at 8 kHz IRQ rate
        auto wr = RTShmRing::WriteIndexProxy(*shmControlBlock_)
                      .load(std::memory_order_relaxed);
        auto rd = RTShmRing::ReadIndexProxy(*shmControlBlock_)
                      .load(std::memory_order_relaxed);
        if (logger_) {
            logger_->info("POP rd={} wr={} used={}  curChunkLeft={}B  copyThisCall={}B",
                          rd, wr, wr - rd,
                          currentChunk_.remainingBytes(),
                          targetBufferSize);
        }
        statsTicks = 0;
    }

    while (remaining > 0) {
        // If current chunk is exhausted, try to pop next one
        if (currentChunk_.remainingBytes() == 0) {
            if (!popNextChunk()) {
                // Underrun: no more valid audio chunks
                gotAllData = false;
                break;
            }
        }

        uint32_t availableInChunk = currentChunk_.remainingBytes();
        size_t   toCopy           = std::min(remaining, static_cast<size_t>(availableInChunk));

        // Only count as “partial” if we're consuming < full chunk on first access
        bool wasPartialConsumption = (currentChunk_.consumedBytes == 0 &&
                                      toCopy < currentChunk_.totalBytes);

        std::memcpy(
            writePtr,
            currentChunk_.audioDataPtr + currentChunk_.consumedBytes,
            toCopy
        );

        writePtr += toCopy;
        remaining -= toCopy;
        currentChunk_.consumedBytes += static_cast<uint32_t>(toCopy);
        totalBytesConsumed_ += toCopy;

        if (wasPartialConsumption) {
            partialChunkConsumptions_++;
        }
    }

    // === 5. If we got a full buffer, convert in-place to AM824; else zero-fill & note underrun ===
    if (gotAllData && remaining == 0) {
        formatToAM824InPlace(targetBuffer, targetBufferSize);
        result.generatedSilence = false;
    } else {
        // Partial or complete underrun: fill remainder with silence
        if (remaining > 0) {
            std::memset(writePtr, 0, remaining);
        }
        handleUnderrun(info);
    }

    result.dataLength = targetBufferSize;

    // === 6. Update performance timing ===
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(endTime - startTime);
    fillPacketCallCount_++;
    totalFillPacketTimeNs_ += duration.count();

    return result;
}

bool IsochPacketProvider::popNextChunk() {
    if (!shmControlBlock_ || !shmRingArray_) {
        return false;
    }

    AudioTimeStamp timestamp;
    uint32_t dataBytes;
    const std::byte* audioPtr;

    // Use your zero-copy pop API
    if (!RTShmRing::pop(*shmControlBlock_, shmRingArray_, timestamp, dataBytes, audioPtr)) {
        shmUnderrunCount_++;
        currentChunk_.invalidate();
        return false;
    }

    // Cache the chunk data
    currentChunk_.timeStamp = timestamp;
    currentChunk_.totalBytes = dataBytes;
    currentChunk_.audioDataPtr = audioPtr;
    currentChunk_.consumedBytes = 0;
    currentChunk_.valid = true;
    
    shmPopCount_++;
    return true;
}

bool IsochPacketProvider::isReadyForStreaming() const {
    if (!shmControlBlock_) {
        return false;
    }
    
    auto wr = RTShmRing::WriteIndexProxy(*shmControlBlock_).load(std::memory_order_acquire);
    auto rd = RTShmRing::ReadIndexProxy(*shmControlBlock_).load(std::memory_order_acquire);
    
    if (shmControlBlock_->capacity == 0) {
        return false;
    }
    
    uint32_t fill = static_cast<uint32_t>((wr - rd) * 100 / shmControlBlock_->capacity);
    return fill >= INITIAL_FILL_TARGET_PERCENT;   // e.g. 25 %
}

void IsochPacketProvider::reset() {
    currentChunk_.invalidate();
    totalBytesConsumed_ = 0;
    shmPopCount_ = 0;
    shmUnderrunCount_ = 0;
    formatValidationErrors_ = 0;
    partialChunkConsumptions_ = 0;
    fillPacketCallCount_ = 0;
    totalFillPacketTimeNs_ = 0;
    lastStatsTime_ = std::chrono::steady_clock::now();
    
    if (logger_) {
        logger_->info("IsochPacketProvider reset (direct SHM mode)");
    }
}

void IsochPacketProvider::handleUnderrun(const TransmitPacketInfo& info) {
    shmUnderrunCount_++;
    
    // Log periodically to avoid spam
    if ((shmUnderrunCount_ % 100) == 1) {
        uint32_t fillLevel = getCurrentShmFillLevel();
        if (logger_) {
            logger_->warn("SHM underrun detected at Seg={}, Pkt={}, AbsPkt={}. Total Count={}, SHM Fill={}%",
                         info.segmentIndex, info.packetIndexInGroup, info.absolutePacketIndex, 
                         shmUnderrunCount_.load(), fillLevel);
        }
    }
}

void IsochPacketProvider::formatToAM824InPlace(uint8_t* buffer, size_t bufferSize) const {
    int32_t* samplesPtr = reinterpret_cast<int32_t*>(buffer);
    size_t numSamples = bufferSize / sizeof(int32_t);

    for (size_t i = 0; i < numSamples; ++i) {
        int32_t sample = samplesPtr[i];
        sample &= 0x00FFFFFF;  // Mask to 24-bit
        uint32_t am824Sample = (AM824_LABEL << LABEL_SHIFT) | sample;
        samplesPtr[i] = OSSwapHostToBigInt32(am824Sample);
    }
}

uint32_t IsochPacketProvider::getCurrentShmFillLevel() const {
    if (!shmControlBlock_) {
        return 0;
    }
    
    auto wr = RTShmRing::WriteIndexProxy(*shmControlBlock_).load(std::memory_order_acquire);
    auto rd = RTShmRing::ReadIndexProxy(*shmControlBlock_).load(std::memory_order_acquire);
    
    if (shmControlBlock_->capacity == 0) {
        return 0;
    }
    
    uint64_t used = (wr >= rd) ? (wr - rd) : 0;
    return static_cast<uint32_t>((used * 100) / shmControlBlock_->capacity);
}

bool IsochPacketProvider::validateShmFormat() const {
    if (!shmControlBlock_) {
        return false;
    }
    
    return RTShmRing::ValidateFormat(*shmControlBlock_);
}

IsochPacketProvider::DiagnosticStats IsochPacketProvider::getDiagnostics() const {
    DiagnosticStats stats;
    stats.totalBytesConsumed = totalBytesConsumed_.load();
    stats.shmPopCount = shmPopCount_.load();
    stats.shmUnderrunCount = shmUnderrunCount_.load();
    stats.formatValidationErrors = formatValidationErrors_.load();
    stats.partialChunkConsumptions = partialChunkConsumptions_.load();
    stats.currentShmFillPercent = getCurrentShmFillLevel();
    
    // Calculate average fill packet duration
    uint64_t totalCalls = fillPacketCallCount_.load();
    uint64_t totalTimeNs = totalFillPacketTimeNs_.load();
    stats.avgFillPacketDurationUs = totalCalls > 0 ? 
        (static_cast<double>(totalTimeNs) / static_cast<double>(totalCalls)) / 1000.0 : 0.0;
    
    return stats;
}

void IsochPacketProvider::resetDiagnostics() {
    totalBytesConsumed_ = 0;
    shmPopCount_ = 0;
    shmUnderrunCount_ = 0;
    formatValidationErrors_ = 0;
    partialChunkConsumptions_ = 0;
    fillPacketCallCount_ = 0;
    totalFillPacketTimeNs_ = 0;
    lastStatsTime_ = std::chrono::steady_clock::now();
    
    if (logger_) {
        logger_->debug("IsochPacketProvider diagnostics reset");
    }
}

} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/AmdtpTransmitter.cpp ===
#include "Isoch/core/AmdtpTransmitter.hpp"
#include "Isoch/core/IsochTransmitBufferManager.hpp"
#include "Isoch/core/IsochPortChannelManager.hpp"
#include "Isoch/core/IsochTransmitDCLManager.hpp"
#include "Isoch/core/IsochTransportManager.hpp"
#include "Isoch/core/IsochPacketProvider.hpp"
#include <mach/mach_time.h>        // For mach_absolute_time
#include <CoreServices/CoreServices.h> // For endian swap
#include <vector>
#include <chrono>                  // For timing/sleep
#include <os/log.h>

namespace FWA {
namespace Isoch {

// --- Factory Method ---
std::shared_ptr<AmdtpTransmitter> AmdtpTransmitter::create(const TransmitterConfig& config) {
    os_log(OS_LOG_DEFAULT, "Creating AmdtpTransmitter with config: numGroups=%u, packetsPerGroup=%u",
           config.numGroups, config.packetsPerGroup);
    // Using make_shared with a helper struct to handle enable_shared_from_this properly
    struct MakeSharedEnabler : public AmdtpTransmitter {
        MakeSharedEnabler(const TransmitterConfig& cfg) : AmdtpTransmitter(cfg) {}
    };
    return std::make_shared<MakeSharedEnabler>(config);
}


ITransmitPacketProvider* AmdtpTransmitter::getPacketProvider() const {
    return packetProvider_.get(); // Return raw pointer from unique_ptr
}

std::expected<void, IOKitError> AmdtpTransmitter::startTransmit() {
    os_log(OS_LOG_DEFAULT, "AmdtpTransmitter::startTransmit called");
    // Temporary storage for callback info
    MessageCallback callback_to_notify = nullptr;
    void* refcon_to_notify = nullptr;
    IOKitError error_code = IOKitError::Success; // Use a status variable

    { // --- Start Scope for stateMutex_ ---
        std::lock_guard<std::mutex> lock(stateMutex_);
        if (!initialized_) {
            logger_->error("startTransmit: Not initialized.");
            return std::unexpected(IOKitError::NotReady);
        }
        if (running_) {
            logger_->warn("startTransmit: Already running.");
            return {}; // Not an error
        }
        if (!portChannelManager_ || !dclManager_ || !transportManager_ || !packetProvider_ || !bufferManager_) {
            logger_->error("startTransmit: Required components not available.");
            return std::unexpected(IOKitError::NotReady);
        }

        logger_->info("AmdtpTransmitter starting transmit...");

        // --- 1. Reset State ---
        initializeCIPState(); // Reset DBC, SYT state, first callback flag etc.

        // --- 2. Initial DCL Memory Preparation Loop ---
        // Pre-fill the *memory* associated with *all* DCLs with initial safe values
        logger_->debug("Performing initial memory preparation for DCL ring...");
        uint32_t totalPacketsToPrep = config_.numGroups * config_.packetsPerGroup;

        for (uint32_t absPktIdx = 0; absPktIdx < totalPacketsToPrep; ++absPktIdx) {
            uint32_t g = absPktIdx / config_.packetsPerGroup;
            uint32_t p = absPktIdx % config_.packetsPerGroup;

            // --- 2a. Get Buffer Pointers ---
            auto cipHdrPtrExp = bufferManager_->getPacketCIPHeaderPtr(g, p);
            uint8_t* audioDataTargetPtr = nullptr;
            if (bufferManager_->getClientAudioBufferPtr() && bufferManager_->getClientAudioBufferSize() > 0) {
                audioDataTargetPtr = bufferManager_->getClientAudioBufferPtr()
                                   + (absPktIdx * bufferManager_->getAudioPayloadSizePerPacket())
                                        % bufferManager_->getClientAudioBufferSize();
            }
            auto isochHdrPtrExp = bufferManager_->getPacketIsochHeaderPtr(g, p); // For template update

            if (!cipHdrPtrExp || !audioDataTargetPtr || !isochHdrPtrExp) {
                logger_->error("startTransmit: Failed to get buffer pointers for initial prep G={}, P={}", g, p);
                // Don't start if buffers aren't right
                error_code = IOKitError::InternalError;
                // Go to end of locked scope
                break;
            }
            CIPHeader* cipHdrTarget = reinterpret_cast<CIPHeader*>(cipHdrPtrExp.value());
            size_t audioPayloadTargetSize = bufferManager_->getAudioPayloadSizePerPacket();
            IsochHeaderData* isochHdrTarget = reinterpret_cast<IsochHeaderData*>(isochHdrPtrExp.value());

            // --- 2b. Fill Audio Payload (Initial Silence) ---
            // Ask provider to fill - it should generate silence if its buffer is empty.
            TransmitPacketInfo dummyInfo = {
                .segmentIndex        = g,
                .packetIndexInGroup  = p,
                .absolutePacketIndex = absPktIdx
            };
            PreparedPacketData packetDataStatus = packetProvider_->fillPacketData(
                audioDataTargetPtr,
                audioPayloadTargetSize,
                dummyInfo
            );

            // --- 2c. Prepare CIP Header (Initial State) ---
            // Directly set a minimal NO_DATA header for initial prep
            cipHdrTarget->sid_byte       = 0; // Will be set by HW or Port later
            cipHdrTarget->dbs            = 2; // AM824 Stereo
            cipHdrTarget->fn_qpc_sph_rsv = 0;
            cipHdrTarget->fmt_eoh1       = (0x10 << 2) | 0x01; // FMT=0x10 (AM824), EOH=1
            cipHdrTarget->fdf           = 0xFF;                // NO_DATA
            cipHdrTarget->syt           = OSSwapHostToBigInt16(0xFFFF); // NO_INFO
            cipHdrTarget->dbc           = 0;                   // Initial DBC

            // --- 2d. Prepare Isoch Header Template ---
            // Set the channel, tag, tcode in the template memory
            uint8_t fwChannel = portChannelManager_->getActiveChannel()
                                    .value_or(config_.initialChannel & 0x3F);
            // Calculate expected data_length (CIP + Payload, even if payload is silence for now)
            uint16_t dataLength = kTransmitCIPHeaderSize + audioPayloadTargetSize;
            isochHdrTarget->data_length  = OSSwapHostToBigInt16(dataLength);
            isochHdrTarget->tag_channel  = (1 << 6) | (fwChannel & 0x3F); // Tag=1
            isochHdrTarget->tcode_sy     = (0xA << 4) | 0;              // TCode=A, Sy=0
        } // End initial prep loop

        // Check for error from the loop
        if (error_code != IOKitError::Success) {
            return std::unexpected(error_code);
        }

        logger_->debug("Initial memory preparation complete.");

        // --- 3. Fixup DCL Jumps ---
        // Link the last DCL back to the first one and notify the port.
        auto localPort = portChannelManager_->getLocalPort();
        if (!localPort) {
            logger_->error("startTransmit: Cannot get local port for DCL fixup.");
            error_code = IOKitError::NotReady; // Store error
            // Go to end of locked scope
        } else {
            auto dclFixupResult = dclManager_->fixupDCLJumpTargets(localPort);
            if (!dclFixupResult) {
                logger_->error("startTransmit: Failed to fix up DCL jump targets: {}",
                              iokit_error_category().message(static_cast<int>(dclFixupResult.error())));
                error_code = dclFixupResult.error(); // Store error
                // Go to end of locked scope
            }
        }

        // --- PLACE DCL PROGRAM DUMP HERE (Attempt 1) ---
        // At this point, the DCLs should be created, linked, and their initial content prepared.
        // The IsochPortChannelManager should also have its nuDCLPool_ if dclManager_ got it.
        if (portChannelManager_) { // Ensure portChannelManager_ exists
            IOFireWireLibNuDCLPoolRef dclPool = portChannelManager_->getNuDCLPool();
            if (dclPool) {
                CFArrayRef dclArray = (*dclPool)->GetDCLs(dclPool);
                if (dclArray) {
                    CFIndex dclCount = CFArrayGetCount(dclArray);
                    os_log(OS_LOG_DEFAULT,
                           "AmdtpTransmitter::startTransmit: NuDCLPool GetDCLs reports %ld DCLs.",
                           dclCount);

                    // You can optionally iterate and log the DCLRef pointers for more detail
                    // for (CFIndex i = 0; i < dclCount; ++i) {
                    //     NuDCLRef dcl = (NuDCLRef)CFArrayGetValueAtIndex(dclArray, i);
                    //     logger_->trace("  DCL[{}]: {:p}", i, (void*)dcl);
                    // }

                    CFRelease(dclArray); // IMPORTANT: Release the CFArrayRef
                }

                os_log(OS_LOG_DEFAULT, "--- DUMPING DCL PROGRAM (TRANSMIT) BEFORE TRANSPORT START ---");
                (*dclPool)->PrintProgram(dclPool); // Call PrintProgram
                logger_->info("--- END DCL PROGRAM DUMP (TRANSMIT) ---");
            } else {
                logger_->error("AmdtpTransmitter::startTransmit: NuDCLPool is null from portChannelManager_, cannot dump DCL program.");
                os_log(OS_LOG_DEFAULT,
                       "AmdtpTransmitter::startTransmit: NuDCLPool is null from portChannelManager_, cannot dump DCL program.");
            }
        } else {
            os_log(OS_LOG_DEFAULT,
                   "AmdtpTransmitter::startTransmit: portChannelManager_ is null, cannot get NuDCLPool to dump DCL program.");
        }

        // --- 4. Start Transport (only if no error so far) ---
        if (error_code == IOKitError::Success) {
            auto channel = portChannelManager_->getIsochChannel();
            if (!channel) {
                logger_->error("startTransmit: Cannot get isoch channel to start transport.");
                error_code = IOKitError::NotReady; // Store error
            } else {
                auto startResult = transportManager_->start(channel);
                if (!startResult) {
                    logger_->error("startTransmit: Failed to start transport manager: {}",
                                   iokit_error_category().message(static_cast<int>(startResult.error())));
                    error_code = startResult.error(); // Store error
                }
            }
        }

        // --- 5. Update State (only if no error so far) ---
        if (error_code == IOKitError::Success) {
            running_                 = true;
            firstDCLCallbackOccurred_ = false; // Reset for timing measurements
            logger_->info("AmdtpTransmitter transmit started successfully.");

            // -- Read callback info while lock is held --
            callback_to_notify  = messageCallback_;
            refcon_to_notify    = messageCallbackRefCon_;
            // -----------------------------------------
        }
    } // --- End Scope for stateMutex_ --- lock is released here

    // --- Handle return/notification outside the lock ---
    if (error_code != IOKitError::Success) {
        // An error occurred during setup
        return std::unexpected(error_code);
    }

    // Call the callback directly after releasing the lock
    if (callback_to_notify) {
        callback_to_notify(static_cast<uint32_t>(TransmitterMessage::StreamStarted), 0, 0, refcon_to_notify);
    }

    return {}; // Success
}

// --- IMPLEMENT stopTransmit ---
std::expected<void, IOKitError> AmdtpTransmitter::stopTransmit() {
    std::lock_guard<std::mutex> lock(stateMutex_); // Ensure exclusive access
    if (!initialized_) {
        return {}; // Nothing to do
    }
    if (!running_) {
        return {}; // Already stopped
    }

    logger_->info("AmdtpTransmitter stopping transmit...");
    running_ = false; // Signal handlers/callbacks to stop processing ASAP

    // Check required components for cleanup
    if (!portChannelManager_ || !transportManager_) {
        logger_->error("stopTransmit: PortChannelManager or TransportManager missing. Cannot stop cleanly.");
        // Setting running_ to false might prevent some crashes.
        return std::unexpected(IOKitError::NotReady);
    }

    // Get the channel to stop transport
    auto channel = portChannelManager_->getIsochChannel();
    if (!channel) {
        logger_->error("stopTransmit: Cannot get IsochChannel to stop transport.");
        running_ = true; // Revert state if we can't proceed
        return std::unexpected(IOKitError::NotReady);
    }

    // Stop the transport manager
    auto stopResult = transportManager_->stop(channel);

    logger_->info("AmdtpTransmitter transmit stopped.");
    notifyMessage(TransmitterMessage::StreamStopped); // Notify client

    if (!stopResult) {
        logger_->error("stopTransmit: TransportManager failed to stop cleanly: {}. State set to stopped, but resources might leak.",
                       iokit_error_category().message(static_cast<int>(stopResult.error())));
        // Return the error from stop so caller knows it wasn't clean
        return std::unexpected(stopResult.error());
    }

    return {}; // Success
}

// --- handleDCLOverrun implementation ---
void AmdtpTransmitter::handleDCLOverrun() {
    // Running check should happen *before* this is called ideally,
    // but double check here.
    if (!running_.load()) return;

    logger_->error("AmdtpTransmitter DCL Overrun detected!");
    notifyMessage(TransmitterMessage::OverrunError);

    // Attempt to stop the transport cleanly
    logger_->warn("Attempting to stop stream due to overrun...");
    auto stopExp = stopTransmit();
    if (!stopExp) {
        logger_->error("Failed to stop stream cleanly during overrun handling: {}",
                       iokit_error_category().message(static_cast<int>(stopExp.error())));
        // At this point, state might be inconsistent.
    }
}

// --- IMPLEMENTATION OF handleDCLComplete (Instance Method) ---
// This is the core real-time loop function called from the RunLoop via the static helper
void AmdtpTransmitter::handleDCLComplete(uint32_t completedGroupIndex) {

    // DEBUG LOGGING
    uint32_t cycleTime;
    IOReturn result = (*interface_)->GetCycleTime(interface_, &cycleTime);
    
    logger_->debug("Callback: group={}, cycle={:08x}", completedGroupIndex, cycleTime);
    
    // Check if we're being called too often
    static uint32_t lastCycle = 0;
    uint32_t cycleDiff = (cycleTime >> 12) - (lastCycle >> 12);
    if (cycleDiff == 0) {
        // logger_->error("🚨 Multiple callbacks in same cycle!");
    }
    lastCycle = cycleTime;

    
    // os_log(OS_LOG_DEFAULT, "AmdtpTransmitter::handleDCLComplete FIRED");
    // logger_->critical("<<<<< AmdtpTransmitter::handleDCLComplete ENTERED for Group: {} >>>>>", completedGroupIndex);
    // --- 1. State Check ---
    // Check running state *without* lock first for performance optimisation
    if (!running_.load(std::memory_order_relaxed)) {
        // logger_->trace("handleDCLComplete: Not running, ignoring callback for group {}", completedGroupIndex);
        return;
    }

    // Get essential components (check for null - should ideally not happen if running)
    auto localPort = portChannelManager_ ? portChannelManager_->getLocalPort() : nullptr;
    if (!localPort || !dclManager_ || !bufferManager_ || !packetProvider_) {
        logger_->error("handleDCLComplete: Required manager component is missing! Stopping stream.");
        // Attempt to stop cleanly, ignoring potential errors during error handling
        auto stopExp = stopTransmit(); // This will acquire the lock if needed
        notifyMessage(TransmitterMessage::Error); // Notify client of error
        return;
    }

    // --- 2. Timing & Debug ---
    uint64_t callbackEntryTime = mach_absolute_time(); // Measure entry time
    if (!firstDCLCallbackOccurred_) {
        firstDCLCallbackOccurred_ = true;
        // Potentially record first callback time for latency estimation
        logger_->info("First DCL completion callback received for group {}", completedGroupIndex);
    }

    // Read hardware completion timestamp for the completed group
    uint32_t completionTimestamp = 0;
    auto tsExp = bufferManager_->getGroupTimestampPtr(completedGroupIndex);
    if (tsExp) {
        completionTimestamp = *tsExp.value();
        // logger_->trace("Completed Group {}: HW Timestamp = {:#010x}", completedGroupIndex, completionTimestamp);
        // TODO: Use this timestamp for PLL/rate estimation later
    } else {
        logger_->warn("Could not get completion timestamp for group {}", completedGroupIndex);
    }

    // --- 3. Determine Next Segment to Fill ---
    // We need to fill the segment that the hardware will encounter *after*
    // the currently executing segments. With a callback interval of 1,
    // when group N completes, the hardware might be starting group N+1.
    // We should prepare group N+2 to ensure double buffering.
    uint32_t fillGroupIndex = (completedGroupIndex + 2) % config_.numGroups;
    logger_->debug("handleDCLComplete: Completed Group = {}, Preparing Group = {}",
                   completedGroupIndex, fillGroupIndex);

    // --- 4. Prepare Next Segment Loop ---
    // Iterate through all packets within the 'fillGroupIndex' segment
    for (uint32_t p = 0; p < config_.packetsPerGroup; ++p) {
        uint32_t absolutePacketIndex = fillGroupIndex * config_.packetsPerGroup + p;

        // --- 4a. Get Buffer Pointers ---
        auto isochHdrPtrExp = bufferManager_->getPacketIsochHeaderPtr(fillGroupIndex, p);
        auto cipHdrPtrExp   = bufferManager_->getPacketCIPHeaderPtr(fillGroupIndex, p);
        uint8_t* audioDataTargetPtr = nullptr;
        if (bufferManager_->getClientAudioBufferPtr() && bufferManager_->getClientAudioBufferSize() > 0) {
            audioDataTargetPtr = bufferManager_->getClientAudioBufferPtr()
                               + (absolutePacketIndex * bufferManager_->getAudioPayloadSizePerPacket())
                                    % bufferManager_->getClientAudioBufferSize();
        }

        if (!isochHdrPtrExp || !cipHdrPtrExp || !audioDataTargetPtr) {
            logger_->error("handleDCLComplete: Failed to get buffer pointers for G={}, P={}. Skipping packet.", fillGroupIndex, p);
            continue;
        }

        IsochHeaderData* isochHdrTarget = reinterpret_cast<IsochHeaderData*>(isochHdrPtrExp.value());
        CIPHeader*       cipHdrTarget   = reinterpret_cast<CIPHeader*>(cipHdrPtrExp.value());
        size_t           audioPayloadTargetSize = bufferManager_->getAudioPayloadSizePerPacket();

        // --- 4b. Prepare TransmitPacketInfo ---
        uint64_t estimatedHostTimeNano    = 0;
        uint32_t estimatedFirewireTimestamp = 0;
        TransmitPacketInfo packetInfo = {
            .segmentIndex        = fillGroupIndex,
            .packetIndexInGroup  = p,
            .absolutePacketIndex = absolutePacketIndex,
            .hostTimestampNano   = estimatedHostTimeNano,
            .firewireTimestamp   = estimatedFirewireTimestamp
        };

        // --- 4c. Fill Audio Data (ask provider) ---
        PreparedPacketData packetDataStatus = packetProvider_->fillPacketData(
            audioDataTargetPtr,
            audioPayloadTargetSize,
            packetInfo
        );

        // --- 4d. Prepare CIP Header Content (using the new centralized method) ---
        uint8_t next_dbc_val_for_state_update;
        bool    next_wasNoData_val_for_state_update;
        generateCIPHeaderContent(cipHdrTarget,                       // Output: where to write the header
                                 this->dbc_count_,                   // Input: current DBC state from member
                                 this->wasNoData_,                   // Input: previous packet type state from member
                                 this->firstDCLCallbackOccurred_.load(), // Input: current atomic bool state
                                 next_dbc_val_for_state_update,    // Output: by reference
                                 next_wasNoData_val_for_state_update // Output: by reference
        );
        // Update transmitter's persistent state AFTER generating the header for *this* packet

        if (cipHdrTarget->fdf == 0xFF) {
           noDataPacketsSent_.fetch_add(1, std::memory_order_relaxed);
        } else {
            dataPacketsSent_.fetch_add(1, std::memory_order_relaxed);
        }

        this->dbc_count_ = next_dbc_val_for_state_update;
        this->wasNoData_ = next_wasNoData_val_for_state_update;

        // --- 4e. Update Isoch Header (based on whether it's a NO_DATA packet from CIP gen) ---
        uint8_t fwChannel = portChannelManager_->getActiveChannel()
                                .value_or(config_.initialChannel & 0x3F);
        isochHdrTarget->tag_channel = (1 << 6) | (fwChannel & 0x3F);
        isochHdrTarget->tcode_sy    = (0xA << 4) | 0;

        // --- 4f. Update DCL Ranges (crucial change here) ---
        IOVirtualRange ranges[2];
        uint32_t numRanges = 0;

        // Range 0: CIP Header (Always present)
        ranges[0].address = reinterpret_cast<IOVirtualAddress>(cipHdrTarget);
        ranges[0].length  = kTransmitCIPHeaderSize;
        numRanges++;

        // Determine if we are sending audio data based on the FDF field of the *just generated* CIP header
        bool sendAudioPayload = (cipHdrTarget->fdf != 0xFF);

        if (sendAudioPayload) {
            ranges[1].address = reinterpret_cast<IOVirtualAddress>(audioDataTargetPtr);
            ranges[1].length  = packetDataStatus.dataLength;
            numRanges++;
            isochHdrTarget->data_length = OSSwapHostToBigInt16(
                kTransmitCIPHeaderSize + packetDataStatus.dataLength);
        } else {
            numRanges = 1;
            isochHdrTarget->data_length = OSSwapHostToBigInt16(kTransmitCIPHeaderSize);
            // logger_->trace("handleDCLComplete: Setting numRanges=1 for SYT-driven NO_DATA G={}, P={}", fillGroupIndex, p);
        }

        auto updateExp = dclManager_->updateDCLPacket(fillGroupIndex, p, ranges, numRanges, nullptr);
        if (!updateExp) {
            logger_->error("handleDCLComplete: Failed to update DCL packet ranges for G={}, P={}: {}",
                fillGroupIndex, p,
                iokit_error_category().message(static_cast<int>(updateExp.error())));
        }
    } // --- End packet loop (p) ---

    // --- 5. Notify Hardware of Memory Updates ---
    // Tell the hardware that the *memory content* (CIP headers, audio data)
    // for the 'fillGroupIndex' has been updated and needs to be re-read before execution.

    // After updating all packet content, before notifying hardware:
    std::atomic_thread_fence(std::memory_order_release);


    auto notifyContentExp = dclManager_->notifySegmentUpdate(localPort, fillGroupIndex);
    if (!notifyContentExp) {
        logger_->error("handleDCLComplete: Failed to notify segment content update for G={}: {}",
                       fillGroupIndex,
                       iokit_error_category().message(static_cast<int>(notifyContentExp.error())));
        // Handle error - might lead to hardware sending stale data.
    }

    // --- 6. No DCL Jump Target Updates Needed ---
    // We use a static circular DCL program configured during setup
    // Hardware follows the pre-defined circular path

    // --- 7. Performance Monitoring (Optional) ---
    uint64_t callbackExitTime = mach_absolute_time();
    uint64_t callbackDuration = callbackExitTime - callbackEntryTime;

    // Convert to milliseconds (this is a simple approximation)
    static mach_timebase_info_data_t timebase;
    if (timebase.denom == 0) {
        mach_timebase_info(&timebase);
    }

    uint64_t durationNanos = callbackDuration * timebase.numer / timebase.denom;
    double   durationMs    = static_cast<double>(durationNanos) / 1000000.0;

    // Log if duration exceeds threshold (e.g., 1ms for real-time audio)
    static const double kWarningThresholdMs = 1.0; // 1ms is quite strict for real-time audio
    // if (durationMs > kWarningThresholdMs) {
    //     logger_->warn("handleDCLComplete: Long processing time for G={}: {:.3f}ms",
    //                   completedGroupIndex, durationMs);
    // }


    // Log the number of packets sent in the last second
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - lastPacketLogTime_);
    if (elapsed.count() >= 1) {
        uint64_t dCnt = dataPacketsSent_.exchange(0, std::memory_order_relaxed);
        uint64_t nCnt = noDataPacketsSent_.exchange(0, std::memory_order_relaxed);
        logger_->info("Packets last second: data={}  no_data={}", dCnt, nCnt);
        lastPacketLogTime_ = now;
    }
}

// --- Static Callbacks ---
void AmdtpTransmitter::DCLCompleteCallback_Helper(uint32_t completedGroupIndex, void* refCon) {
    AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    if (self) self->handleDCLComplete(completedGroupIndex);
}

void AmdtpTransmitter::DCLOverrunCallback_Helper(void* refCon) {
    AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    if (self) self->handleDCLOverrun();
}

void AmdtpTransmitter::TransportFinalize_Helper(void* refCon) {
    // AmdtpTransmitter* self = static_cast<AmdtpTransmitter*>(refCon);
    // if (self) self->handleFinalize(); // If finalize handling is needed
}

// Constructor
AmdtpTransmitter::AmdtpTransmitter(const TransmitterConfig& config)
    : config_(config),
      logger_(config.logger ? config.logger : spdlog::default_logger()) {
    logger_->info("AmdtpTransmitter constructing...");
    // Initialize other members if necessary
}

// Destructor
AmdtpTransmitter::~AmdtpTransmitter() {
    logger_->info("AmdtpTransmitter destructing...");
    if (running_.load()) {
        // Attempt to stop, log errors but don't throw from destructor
        auto result = stopTransmit();
        if (!result) logger_->error("stopTransmit failed during destruction");
    }
    cleanup();
}

// cleanup
void AmdtpTransmitter::cleanup() noexcept {
    logger_->debug("AmdtpTransmitter cleanup starting...");
    packetProvider_.reset();
    transportManager_.reset();
    dclManager_.reset();
    portChannelManager_.reset();
    bufferManager_.reset();
    initialized_ = false;
    running_     = false;
    logger_->debug("AmdtpTransmitter cleanup finished."); 
}

// setupComponents
std::expected<void, IOKitError> AmdtpTransmitter::setupComponents(IOFireWireLibNubRef interface) {
    logger_->debug("AmdtpTransmitter::setupComponents - STUB");
    // Create instances...
    bufferManager_      = std::make_unique<IsochTransmitBufferManager>(logger_);
    portChannelManager_ = std::make_unique<IsochPortChannelManager>(logger_, interface,
                                                                      runLoopRef_, true /*isTalker*/);
    dclManager_        = std::make_unique<IsochTransmitDCLManager>(logger_);
    transportManager_  = std::make_unique<IsochTransportManager>(logger_);
    // Old one:
    // packetProvider_ = std::make_unique<IsochPacketProvider>(logger_, config_.clientBufferSize);
    packetProvider_ = std::make_unique<IsochPacketProvider>(logger_);

    interface_ = interface; // Store the interface reference

    // Initialize... (Error checking omitted for brevity in stub)
    bufferManager_->setupBuffers(config_);
    portChannelManager_->initialize();
    auto dclPool = portChannelManager_->getNuDCLPool();
    if (!dclPool) return std::unexpected(IOKitError::NotReady);

    auto dclProgResult = dclManager_->createDCLProgram(config_, dclPool, *bufferManager_);
    if (!dclProgResult) return std::unexpected(dclProgResult.error());
    DCLCommand* dclProgramHandle = dclProgResult.value();

    portChannelManager_->setupLocalPortAndChannel(dclProgramHandle,
                                                 bufferManager_->getBufferRange());
    dclManager_->setDCLCompleteCallback(DCLCompleteCallback_Helper, this); // Set internal callback forwarder
    dclManager_->setDCLOverrunCallback(DCLOverrunCallback_Helper, this);

    return {};
}

// initialize
std::expected<void, IOKitError> AmdtpTransmitter::initialize(IOFireWireLibNubRef interface) {
    logger_->debug("AmdtpTransmitter::initialize");
    std::lock_guard<std::mutex> lock(stateMutex_);
    if (initialized_) return std::unexpected(IOKitError::Busy);
    if (!interface)  return std::unexpected(IOKitError::BadArgument);

    runLoopRef_ = CFRunLoopGetCurrent(); // Assign runloop

    auto setupResult = setupComponents(interface); // Call setup
    if (!setupResult) {
        cleanup();
        return setupResult;
    }
    initialized_ = true;
    return {};
}

// configure
std::expected<void, IOKitError> AmdtpTransmitter::configure(IOFWSpeed speed, uint32_t channel) {
    logger_->debug("AmdtpTransmitter::configure(Speed={}, Channel={})", (int)speed, channel);
    std::lock_guard<std::mutex> lock(stateMutex_);
    if (!initialized_)               return std::unexpected(IOKitError::NotReady);
    if (running_)                    return std::unexpected(IOKitError::Busy);
    if (!portChannelManager_)        return std::unexpected(IOKitError::NotReady);

    config_.initialSpeed   = speed;
    config_.initialChannel = channel;
    return portChannelManager_->configure(speed, channel);
}

// pushAudioData
bool AmdtpTransmitter::pushAudioData(const void* buffer, size_t bufferSizeInBytes) {
    // logger_->trace("AmdtpTransmitter::pushAudioData"); // Too noisy
    if (!initialized_ || !packetProvider_) return false;
    return packetProvider_->pushAudioData(buffer, bufferSizeInBytes);
}

// setMessageCallback
void AmdtpTransmitter::setMessageCallback(MessageCallback callback, void* refCon) {
    logger_->debug("AmdtpTransmitter::setMessageCallback");
    std::lock_guard<std::mutex> lock(stateMutex_);
    messageCallback_      = callback;
    messageCallbackRefCon_ = refCon;
}

// notifyMessage
void AmdtpTransmitter::notifyMessage(TransmitterMessage msg, uint32_t p1, uint32_t p2) {
    // logger_->trace("AmdtpTransmitter::notifyMessage ({})", static_cast<uint32_t>(msg));
    MessageCallback callback = nullptr;
    void* refCon             = nullptr;
    {
        std::lock_guard<std::mutex> lock(stateMutex_);
        callback = messageCallback_;
        refCon   = messageCallbackRefCon_;
    }
    if (callback) {
        callback(static_cast<uint32_t>(msg), p1, p2, refCon);
    }
}

// initializeCIPState
void AmdtpTransmitter::initializeCIPState() {
    logger_->debug("AmdtpTransmitter::initializeCIPState");
    dbc_count_   = 0;
    wasNoData_   = true; // Start assuming previous was NoData for both modes initially

    // Initialize state for "NonBlocking" (current) AmdtpTransmitter SYT logic
    sytOffset_   = TICKS_PER_CYCLE;
    sytPhase_    = 0;

    // Initialize state for "Blocking" (UniversalTransmitter-style) SYT logic
    sytOffset_blocking_ = TICKS_PER_CYCLE;
    sytPhase_blocking_  = 0;

    firstDCLCallbackOccurred_ = false;
    expectedTimeStampCycle_   = 0;
}

AmdtpTransmitter::NonBlockingSytParams AmdtpTransmitter::calculateNonBlockingSyt(
    uint8_t current_dbc_state, bool previous_wasNoData_state) {
    NonBlockingSytParams params;

    if (!firstDCLCallbackOccurred_) {
        params.isNoData   = true;
        params.syt_value  = 0xFFFF;
    } else {
        if (sytOffset_ >= TICKS_PER_CYCLE) {
            sytOffset_ -= TICKS_PER_CYCLE;
        } else {
            uint32_t phase    = sytPhase_ % SYT_PHASE_MOD;
            bool     addExtra = (phase && !(phase & 3)) || (sytPhase_ == (SYT_PHASE_RESET - 1));
            sytOffset_ += BASE_TICKS;
            if (addExtra) {
                sytOffset_ += 1;
            }
            if (++sytPhase_ >= SYT_PHASE_RESET) {
                sytPhase_ = 0;
            }
        }

        if (sytOffset_ >= TICKS_PER_CYCLE) {
            params.isNoData  = true;
            params.syt_value = 0xFFFF;
        } else {
            params.isNoData  = false;
            params.syt_value = static_cast<uint16_t>(sytOffset_);
        }
    }

    return params;
}

// Constants for SFC (Sample Frequency Code)
constexpr uint8_t SFC_44K1HZ = 0x01;
constexpr uint8_t SFC_48KHZ  = 0x02;

void AmdtpTransmitter::generateCIPHeaderContent(CIPHeader* outHeader,
                                                uint8_t current_dbc_state,
                                                bool previous_wasNoData_state,
                                                bool first_dcl_callback_occurred_state_param,
                                                uint8_t& next_dbc_for_state,
                                                bool& next_wasNoData_for_state) {
    // Check preconditions
    if (!outHeader || !portChannelManager_ || !this->bufferManager_) {
        if (logger_) logger_->error("generateCIPHeaderContent: Preconditions not met (null pointers).");
        if (outHeader) {
            outHeader->fdf = 0xFF;
            outHeader->syt = OSSwapHostToBigInt16(0xFFFF);
            outHeader->dbc = current_dbc_state;
        }
        next_dbc_for_state      = current_dbc_state;
        next_wasNoData_for_state = true;
        return;
    }

    // --- Get Node ID, Set static fields ---
    uint16_t nodeID   = portChannelManager_->getLocalNodeID().value_or(0x3F);
    outHeader->sid_byte       = static_cast<uint8_t>(nodeID & 0x3F);
    outHeader->dbs            = 2;
    outHeader->fn_qpc_sph_rsv = 0;
    outHeader->fmt_eoh1       = (0x10 << 2) | 0x01;

    // Local variables for this function's calculations
    bool   calculated_isNoData_for_this_packet  = true;
    uint16_t calculated_sytVal_for_this_packet = 0xFFFF;
    uint8_t  sfc_for_this_packet                = SFC_48KHZ;

    // Determine SFC based on config
    if (config_.sampleRate == 44100.0) {
        sfc_for_this_packet = SFC_44K1HZ;
    } else if (config_.sampleRate == 48000.0) {
        sfc_for_this_packet = SFC_48KHZ;
    } else {
        if (logger_) {
            logger_->warn("generateCIPHeaderContent: Unsupported sample rate {:.1f}Hz, using SFC for 48kHz as fallback.",
                          config_.sampleRate);
        }
    }

    // --- Call Strategy-Specific SYT Calculation ---
    switch (config_.transmissionType) {
        case TransmissionType::Blocking: {
            BlockingSytParams sytParams = calculateBlockingSyt();
            calculated_isNoData_for_this_packet = sytParams.isNoData;
            calculated_sytVal_for_this_packet   = sytParams.syt_value;
            break;
        }
        case TransmissionType::NonBlocking:
        default: {
            NonBlockingSytParams sytParams = calculateNonBlockingSyt(current_dbc_state,
                                                                      previous_wasNoData_state);
            calculated_isNoData_for_this_packet = sytParams.isNoData;
            calculated_sytVal_for_this_packet   = sytParams.syt_value;
            break;
        }
    }

    // --- Set Dynamic Fields (FDF, SYT, DBC) ---
    if (calculated_isNoData_for_this_packet) {
        outHeader->fdf = 0xFF;
        outHeader->syt = OSSwapHostToBigInt16(0xFFFF);
        outHeader->dbc = current_dbc_state;
    } else {
        outHeader->fdf = sfc_for_this_packet;
        outHeader->syt = OSSwapHostToBigInt16(calculated_sytVal_for_this_packet);

        uint8_t blocksPerPacket = this->bufferManager_->getAudioPayloadSizePerPacket() / 8;
        if (blocksPerPacket == 0 && !calculated_isNoData_for_this_packet) {
            blocksPerPacket = 1;
        }

        if (previous_wasNoData_state) {
            outHeader->dbc = current_dbc_state;
        } else {
            outHeader->dbc = (current_dbc_state + blocksPerPacket) & 0xFF;
        }
    }

    // --- Update state for the *next* call (via output parameters) ---
    next_dbc_for_state       = outHeader->dbc;
    next_wasNoData_for_state = calculated_isNoData_for_this_packet;
}

// AmdtpTransmitter::BlockingSytParams AmdtpTransmitter::calculateBlockingSyt() { // <<<< DEFINITION
//     BlockingSytParams params;

//     if (!this->firstDCLCallbackOccurred_) { 
//         params.isNoData  = true;
//         params.syt_value = 0xFFFF;
//         return params; 
//     }

//     // ** Step 1 of 3: Check for a full 3072‐tick cycle **
//     if (sytOffset_blocking_ >= TICKS_PER_CYCLE) {
//         // We've accumulated one full FireWire cycle → skip this callback entirely
//         sytOffset_blocking_ -= TICKS_PER_CYCLE;
//         return params;   // EARLY RETURN: no packet emitted this iteration
//     }

//     // ** Step 2 of 3: Otherwise, update offset by BASE_TICKS_BLOCKING (+ occasional +1) **
//     uint32_t phase    = sytPhase_blocking_ % SYT_PHASE_MOD_BLOCKING;
//     bool     addExtra = (phase && !(phase & 3)) 
//                         || (sytPhase_blocking_ == (SYT_PHASE_RESET_BLOCKING - 1));
//     sytOffset_blocking_ += BASE_TICKS_BLOCKING;
//     if (addExtra) {
//         sytOffset_blocking_ += 1;
//     }
//     if (++sytPhase_blocking_ >= SYT_PHASE_RESET_BLOCKING) {
//         sytPhase_blocking_ = 0;
//     }

//     // ** Step 3 of 3: Now decide NO_DATA vs. data packet **
//     if (sytOffset_blocking_ >= TICKS_PER_CYCLE) {
//         params.isNoData  = true;
//         params.syt_value = 0xFFFF;
//     } else {
//         params.isNoData  = false;
//         params.syt_value = static_cast<uint16_t>(sytOffset_blocking_);
//     }
//     return params;
// }

AmdtpTransmitter::BlockingSytParams AmdtpTransmitter::calculateBlockingSyt() {
    BlockingSytParams params;

    // 1) If we haven't had a DCL callback yet, hold off on sending data
    if (!this->firstDCLCallbackOccurred_.load()) {
        params.isNoData  = true;
        params.syt_value = 0xFFFF;   // no-data
        return params;
    }

    // 2) If offset >= one full FireWire cycle (3072), subtract and emit NO_DATA
    if (sytOffset_blocking_ >= TICKS_PER_CYCLE) {
        sytOffset_blocking_ -= TICKS_PER_CYCLE;
        params.isNoData  = true;     // mark no-data on that overflow
        params.syt_value = 0xFFFF;
        return params;
    }

    // 3) Otherwise, advance by BASE_TICKS_BLOCKING + occasional “+1” jitter
    uint32_t phase    = sytPhase_blocking_ % SYT_PHASE_MOD_BLOCKING;   // 0..146
    bool     addExtra = (phase && !(phase & 3)) 
                         || (sytPhase_blocking_ == (SYT_PHASE_RESET_BLOCKING - 1));
    sytOffset_blocking_ += BASE_TICKS_BLOCKING;  // = 565 on each iteration
    if (addExtra) {
        sytOffset_blocking_ += 1;                // +1 every 4th iteration
    }
    if (++sytPhase_blocking_ >= SYT_PHASE_RESET_BLOCKING) {
        sytPhase_blocking_ = 0;
    }

    // 4) Now decide per-packet if it’s data or no-data
    if (sytOffset_blocking_ >= TICKS_PER_CYCLE) {
        // overflow→no-data
        params.isNoData  = true;
        params.syt_value = 0xFFFF;
    } else {
        // within cycle → data packet, embed the SYT
        params.isNoData  = false;
        params.syt_value = static_cast<uint16_t>(sytOffset_blocking_);
    }

    return params;
}

} // namespace Isoch
} // namespace FWA


=== src/Isoch/core/IsochTransmitDCLManager.cpp ===
#include "Isoch/core/IsochTransmitDCLManager.hpp"
#include "Isoch/interfaces/ITransmitBufferManager.hpp" // Full definition needed now
#include <vector>
#include <stdexcept> // For potential exceptions if needed
#include <cstring> // For bzero
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOFireWireLibIsoch.h>
#include <IOKit/firewire/IOFireWireLib.h>   

namespace FWA {
namespace Isoch {

IsochTransmitDCLManager::IsochTransmitDCLManager(std::shared_ptr<spdlog::logger> logger)
 : logger_(std::move(logger)) {
    if (logger_) logger_->debug("IsochTransmitDCLManager created");
}

IsochTransmitDCLManager::~IsochTransmitDCLManager() {
    reset();
    if (logger_) logger_->debug("IsochTransmitDCLManager destroyed");
}

void IsochTransmitDCLManager::reset() {
     std::lock_guard<std::mutex> lock(mutex_);
     // DCLs are owned by the pool, just clear refs
     dclProgramRefs_.clear();
     callbackInfos_.clear();
      for (CFMutableSetRef bag : updateBags_) {
         if (bag) CFRelease(bag);
     }
     updateBags_.clear();
     firstDCLRef_ = nullptr;
     lastDCLRef_ = nullptr;
     overrunDCL_ = nullptr;
     nuDCLPool_ = nullptr; // Clear non-owning ref
     dclProgramCreated_ = false;
      if (logger_) logger_->debug("IsochTransmitDCLManager reset");
}

// Basic implementations - returning errors or default values
std::expected<DCLCommand*, IOKitError> IsochTransmitDCLManager::createDCLProgram(
    const TransmitterConfig& config,
    IOFireWireLibNuDCLPoolRef nuDCLPool,
    const ITransmitBufferManager& bufferManager) // Use const ref to Buffer Manager
{
     std::lock_guard<std::mutex> lock(mutex_);
     if (dclProgramCreated_) {
         logger_->warn("createDCLProgram called when already created.");
         return std::unexpected(IOKitError::Busy);
     }
     if (!nuDCLPool) {
          logger_->error("createDCLProgram: NuDCL pool is null.");
         return std::unexpected(IOKitError::BadArgument);
     }

     logger_->info("IsochTransmitDCLManager::createDCLProgram starting...");

     // Store config and pool reference
     config_ = config;
     nuDCLPool_ = nuDCLPool; // Store non-owning ref

     // --- Basic Input Validation ---
     if (config_.numGroups == 0 || config_.packetsPerGroup == 0) {
         logger_->error("createDCLProgram: numGroups or packetsPerGroup is zero.");
         return std::unexpected(IOKitError::BadArgument);
     }
     uint32_t totalPackets = config_.numGroups * config_.packetsPerGroup;
     logger_->debug("  Total packets to create: {}", totalPackets);

     // --- Prepare Internal Structures ---
     try {
        dclProgramRefs_.resize(totalPackets);
        callbackInfos_.resize(config_.numGroups);
        // updateBags_.resize(config_.numGroups); // Not using update bags for now
     } catch (const std::bad_alloc& e) {
         logger_->error("Failed to allocate internal DCL storage: {}", e.what());
         reset();
         return std::unexpected(IOKitError::NoMemory);
     }

     NuDCLSendPacketRef previousDCL = nullptr;

     // --- DCL Allocation Loop ---
     for (uint32_t g = 0; g < config_.numGroups; ++g) {
         // Prepare callback info for this group (even if callback isn't set on all DCLs)
         callbackInfos_[g].manager = this;
         callbackInfos_[g].groupIndex = g;
         // updateBags_[g] = CFSetCreateMutable(nullptr, 0, nullptr); // If using update bags

         for (uint32_t p = 0; p < config_.packetsPerGroup; ++p) {
             uint32_t globalPacketIdx = g * config_.packetsPerGroup + p;

             // --- 1. Get Buffer Pointers for this Packet ---
             auto isochHdrPtrExp = bufferManager.getPacketIsochHeaderPtr(g, p);
             auto cipHdrPtrExp = bufferManager.getPacketCIPHeaderPtr(g, p);
             // For Send DCL, the *source* of audio data is the client buffer area
             uint8_t* audioDataPtr = bufferManager.getClientAudioBufferPtr()
                                   + (globalPacketIdx * bufferManager.getAudioPayloadSizePerPacket()) % bufferManager.getClientAudioBufferSize(); // Cycle through client buffer
             auto timestampPtrExp = bufferManager.getGroupTimestampPtr(g);

             if (!isochHdrPtrExp || !cipHdrPtrExp || !timestampPtrExp || !audioDataPtr) {
                 logger_->error("Failed to get buffer pointers for G={}, P={}", g, p);
                 reset(); // Cleanup partially created DCLs
                 return std::unexpected(IOKitError::NoMemory); // Or more specific error
             }
             uint8_t* isochHdrTemplatePtr = isochHdrPtrExp.value();
             uint8_t* cipHdrPtr = cipHdrPtrExp.value();
             uint32_t* timestampPtr = timestampPtrExp.value();
             size_t audioPayloadSize = bufferManager.getAudioPayloadSizePerPacket();

             // --- 2. Prepare Initial Memory Content (Optional but good practice) ---
             // Isoch Header Template (Minimal: Tag=1, TCode=A. Channel set later?)
             IsochHeaderData* isochHdr = reinterpret_cast<IsochHeaderData*>(isochHdrTemplatePtr);
             isochHdr->data_length = 0; // Hardware fills this
             isochHdr->tag_channel = (1 << 6) | (config_.initialChannel & 0x3F); // Tag=1
             isochHdr->tcode_sy = (0xA << 4) | 0; // TCode=A, Sy=0

             // CIP Header (Initial safe state: NO_DATA)
             CIPHeader* cipHdr = reinterpret_cast<CIPHeader*>(cipHdrPtr);
             bzero(cipHdr, kTransmitCIPHeaderSize);
             cipHdr->fmt_eoh1 = (0x10 << 2) | 0x01; // FMT=0x10 (AM824), EOH=1
             cipHdr->fdf = 0xFF; // NO_DATA
             cipHdr->syt = OSSwapHostToBigInt16(0xFFFF); // NO_INFO

             // Audio Payload (Zero it out initially)
             // bzero(audioDataPtr, audioPayloadSize); // Provider should handle initial silence

             // --- 3. Prepare IOVirtualRange Array ---
             IOVirtualRange ranges[2];
             uint32_t numRanges = 2; // Assume CIP + Payload initially

             // Range 0: CIP Header
             ranges[0].address = reinterpret_cast<IOVirtualAddress>(cipHdrPtr);
             ranges[0].length = kTransmitCIPHeaderSize;

             // Range 1: Audio Payload
             ranges[1].address = reinterpret_cast<IOVirtualAddress>(audioDataPtr);
             ranges[1].length = audioPayloadSize;

             // --- 4. Allocate Send Packet DCL ---
             NuDCLSendPacketRef currentDCL = (*nuDCLPool_)->AllocateSendPacket(
                 nuDCLPool_,
                 nullptr, // updateBag - not using for now
                 numRanges,
                 (::IOVirtualRange*)ranges // Cast to system type
             );

             if (!currentDCL) {
                 logger_->error("Failed to allocate NuDCLSendPacketRef for G={}, P={}", g, p);
                 reset();
                 return std::unexpected(IOKitError::NoMemory);
             }
             dclProgramRefs_[globalPacketIdx] = currentDCL; // Store the reference

             // --- 5. Configure the Allocated DCL ---
             UInt32 dclFlags = kNuDCLDynamic |         // DCL might change (ranges, branch)
                                kNuDCLUpdateBeforeCallback; // Update status/TS before callback

             // Set Isoch Header Template Pointer
             (*nuDCLPool_)->SetDCLUserHeaderPtr(currentDCL, reinterpret_cast<UInt32*>(isochHdrTemplatePtr), nullptr); // Mask is null

             // Set Timestamp Pointer (where hardware WRITES completion time)
             (*nuDCLPool_)->SetDCLTimeStampPtr(currentDCL, timestampPtr);
             // NOTE: Setting a non-NULL timestamp pointer might automatically set kFWNuDCLFlag_TimeStamp
             
            // Set Callback (Conditional)
            bool isFirstPacketInGroup = (p == 0);  // Changed: first packet instead of last
            bool isCallbackGroup = ((g + 1) % config_.callbackGroupInterval == 0);

            if (isFirstPacketInGroup && isCallbackGroup) {  // Changed: use isFirstPacketInGroup
                (*nuDCLPool_)->SetDCLCallback(currentDCL, DCLComplete_Helper);
                (*nuDCLPool_)->SetDCLRefcon(currentDCL, &callbackInfos_[g]); // Pass group info struct addr
                logger_->warn("  Set callback for G={}, P={} (DCL {:p})", g, p, (void*)currentDCL);
            } else {
                (*nuDCLPool_)->SetDCLRefcon(currentDCL, this); // Default refcon
            }

             // Set Final Flags
             (*nuDCLPool_)->SetDCLFlags(currentDCL, dclFlags);

             // --- 6. Link Previous DCL to Current ---
             if (previousDCL) {
                 (*nuDCLPool_)->SetDCLBranch(previousDCL, currentDCL);
             }

             // --- 7. Store First/Update Previous ---
             if (globalPacketIdx == 0) {
                 firstDCLRef_ = currentDCL;
                 logger_->debug("  Stored first DCL: {:p}", (void*)firstDCLRef_);
             }
             previousDCL = currentDCL;

         } // End packet loop (p)
     } // End group loop (g)


     // --- 8. Store Last DCL ---
     lastDCLRef_ = previousDCL; // Should be the last one allocated
     if(lastDCLRef_) logger_->debug("  Stored last DCL: {:p}", (void*)lastDCLRef_); else logger_->error("  Last DCL is NULL after loop!");


     // --- 9. Get Program Handle ---
     // The handle is needed for CreateLocalIsochPort
     DCLCommand* programHandle = (*nuDCLPool_)->GetProgram(nuDCLPool_);
     if (!programHandle) {
        logger_->error("GetProgram returned null after creating DCLs");
        reset();
        return std::unexpected(IOKitError::Error);
    }

     dclProgramCreated_ = true;
     logger_->info("IsochTransmitDCLManager::createDCLProgram finished successfully.");
     return programHandle; // Return the system-compatible handle
}

std::expected<void, IOKitError> IsochTransmitDCLManager::fixupDCLJumpTargets(
    IOFireWireLibLocalIsochPortRef localPort)
{
    std::lock_guard<std::mutex> lock(mutex_); // Ensure thread safety

    // 1. Check Preconditions
    if (!dclProgramCreated_) {
        logger_->error("fixupDCLJumpTargets: DCL program not created yet");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!nuDCLPool_) {
        logger_->error("fixupDCLJumpTargets: nuDCLPool_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!firstDCLRef_) {
        logger_->error("fixupDCLJumpTargets: firstDCLRef_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!lastDCLRef_) {
        logger_->error("fixupDCLJumpTargets: lastDCLRef_ is null");
        return std::unexpected(IOKitError::NotReady);
    }
    if (!localPort) {
        logger_->error("fixupDCLJumpTargets: localPort is null");
        return std::unexpected(IOKitError::BadArgument);
    }

    // 2. Link Last DCL to First DCL
    logger_->debug("Linking last DCL ({:p}) to first DCL ({:p})", (void*)lastDCLRef_, (void*)firstDCLRef_);
    IOReturn result = (*nuDCLPool_)->SetDCLBranch(lastDCLRef_, firstDCLRef_);
    if (result != kIOReturnSuccess) {
        logger_->error("fixupDCLJumpTargets: SetDCLBranch failed with error: 0x{:08X}", result);
        return std::unexpected(IOKitError(result));
    }

    // 3. Notify the Port using the helper function
    logger_->debug("Notifying port about jump update for last DCL ({:p})", (void*)lastDCLRef_);
    NuDCLRef* dclRefPtr = &lastDCLRef_; // Get address of the variable
    result = notifyJumpUpdate(localPort, dclRefPtr); // Call the helper
    if (result != kIOReturnSuccess) {
        logger_->error("fixupDCLJumpTargets: notifyJumpUpdate failed with error: 0x{:08X}", result);
        return std::unexpected(IOKitError(result));
    } else {
        logger_->debug("Successfully notified port about last DCL jump update.");
    }

    logger_->info("IsochTransmitDCLManager::fixupDCLJumpTargets completed successfully.");
    return {};
}

void IsochTransmitDCLManager::setDCLCompleteCallback(TransmitDCLCompleteCallback callback, void* refCon) {
    dclCompleteCallback_ = callback;
    dclCompleteRefCon_ = refCon;
}

void IsochTransmitDCLManager::setDCLOverrunCallback(TransmitDCLOverrunCallback callback, void* refCon) {
    dclOverrunCallback_ = callback;
    dclOverrunRefCon_ = refCon;
}

std::expected<void, IOKitError> IsochTransmitDCLManager::updateDCLPacket(
    uint32_t groupIndex, uint32_t packetIndexInGroup,
    const IOVirtualRange ranges[], uint32_t numRanges,
    const IsochHeaderData* isochHeaderTemplate)
{
     // Remove the lock - DCL access is safe at the driver level
     if (!dclProgramCreated_) return std::unexpected(IOKitError::NotReady);
     if (!nuDCLPool_) return std::unexpected(IOKitError::NotReady); // Should not happen

     NuDCLSendPacketRef dclRef = getDCLRef(groupIndex, packetIndexInGroup);
     if (!dclRef) {
          logger_->error("updateDCLPacket: Could not get DCL Ref for G={}, P={}", groupIndex, packetIndexInGroup);
         return std::unexpected(IOKitError::BadArgument);
     }

     // Update the ranges (data source pointers and lengths)
     // This is the most common update needed.
     IOReturn result = (*nuDCLPool_)->SetDCLRanges(dclRef, numRanges, (::IOVirtualRange*)ranges);
     if (result != kIOReturnSuccess) {
         logger_->error("SetDCLRanges failed for G={}, P={}: 0x{:08X}", groupIndex, packetIndexInGroup, result);
         return std::unexpected(IOKitError(result));
     }
     
     // Update Isoch Header Template Content (if template itself changes, rarely needed)
     if (isochHeaderTemplate) {
          // Note: This requires that the caller has already obtained the correct
          // template pointer location for this DCL's isoch header.
          // The proper way to handle this would be:
          // 1. Get the current header pointer via GetDCLUserHeaderPtr from NuDCLPool
          // 2. Modify its contents
          // Here we just log that this should happen via buffer manager
          logger_->trace("isochHeaderTemplate updates should be handled via buffer manager directly");
     }

     return {};
}

std::expected<void, IOKitError> IsochTransmitDCLManager::notifySegmentUpdate(
     IOFireWireLibLocalIsochPortRef localPort, uint32_t groupIndexToNotify)
{
     // std::lock_guard<std::mutex> lock(mutex_); // May not need lock if dclProgramRefs_ isn't modified
     if (!dclProgramCreated_) return std::unexpected(IOKitError::NotReady);
     if (!localPort) return std::unexpected(IOKitError::BadArgument);
     if (groupIndexToNotify >= config_.numGroups) return std::unexpected(IOKitError::BadArgument);

     // Prepare the list of DCLs in the segment to notify
     uint32_t startIndex = groupIndexToNotify * config_.packetsPerGroup;
     uint32_t count = config_.packetsPerGroup;
     std::vector<NuDCLRef> dclsInSegment;
     dclsInSegment.reserve(count);
     for (uint32_t i = 0; i < count; ++i) {
          if (startIndex + i < dclProgramRefs_.size()) {
              dclsInSegment.push_back(dclProgramRefs_[startIndex + i]);
          } else {
               logger_->error("notifySegmentUpdate: Calculated index out of bounds!");
               return std::unexpected(IOKitError::BadArgument); // Should not happen
          }
     }

     if (dclsInSegment.empty()) {
          logger_->warn("notifySegmentUpdate: No DCLs found for group {}", groupIndexToNotify);
          return {}; // Not an error, but nothing to do
     }

     // Call the helper to notify
     IOReturn result = notifyDCLUpdates(localPort, dclsInSegment.data(), dclsInSegment.size());
     if (result != kIOReturnSuccess) {
          logger_->error("notifyDCLUpdates failed for group {}: 0x{:08X}", groupIndexToNotify, result);
          return std::unexpected(IOKitError(result));
     }
     // logger_->trace("Notified DCL updates for group {}", groupIndexToNotify);
     return {};
}

// updateJumpTargets method removed - we now use a static circular DCL program
// The fixupDCLJumpTargets method handles the circular loop setup during initialization


DCLCommand* IsochTransmitDCLManager::getProgramHandle() const {
    if (!dclProgramCreated_ || !nuDCLPool_) return nullptr;
    return (*nuDCLPool_)->GetProgram(nuDCLPool_);
}

// --- Static Callbacks & Instance Handlers ---
void IsochTransmitDCLManager::DCLComplete_Helper(void* refcon, NuDCLRef dcl) {
     auto* info = static_cast<DCLCallbackInfo*>(refcon);
     if (info && info->manager && info->manager->dclCompleteCallback_) {
          info->manager->dclCompleteCallback_(info->groupIndex, info->manager->dclCompleteRefCon_);
     }
}

void IsochTransmitDCLManager::DCLOverrun_Helper(void* refcon, NuDCLRef dcl) {
    auto* manager = static_cast<IsochTransmitDCLManager*>(refcon);
     if (manager && manager->dclOverrunCallback_) {
         manager->dclOverrunCallback_(manager->dclOverrunRefCon_);
     }
}

void IsochTransmitDCLManager::handleDCLComplete(uint32_t groupIndex, NuDCLRef dcl) {
     // This instance method could do internal state updates if needed before calling client
     if (dclCompleteCallback_) {
        dclCompleteCallback_(groupIndex, dclCompleteRefCon_);
    }
}
void IsochTransmitDCLManager::handleDCLOverrun(NuDCLRef dcl) {
     // This instance method could do internal state updates if needed before calling client
     if (dclOverrunCallback_) {
        dclOverrunCallback_(dclOverrunRefCon_);
    }
}

// --- Private Helpers ---
// Remove const qualifier to match header declaration
NuDCLSendPacketRef IsochTransmitDCLManager::getDCLRef(uint32_t g, uint32_t p) {
     // Remove the lock - read access is safe once program is created
     if (!dclProgramCreated_ || dclProgramRefs_.empty()) return nullptr;
     uint32_t index = g * config_.packetsPerGroup + p;
     if (index >= dclProgramRefs_.size()) return nullptr;
     return dclProgramRefs_[index];
}

IOReturn IsochTransmitDCLManager::notifyDCLUpdates(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef dcls[], uint32_t count) {
     if (!localPort || !dcls || count == 0) return kIOReturnBadArgument;
     
     // Need to pass array of DCLRefs cast to void*
     std::vector<void*> dclPtrList(count);
     for(uint32_t i = 0; i < count; ++i) {
         // --- FIX: Cast the DCLRef *itself* to void*, not its address ---
         dclPtrList[i] = static_cast<void*>(dcls[i]);    // Correct
         
         // Add a check for NULL DCLs just in case
         if (dclPtrList[i] == nullptr) {
             logger_->error("notifyDCLUpdates: Encountered NULL DCLRef at index {}", i);
             return kIOReturnBadArgument; // Safer to return error
         }
     }

     // Call Notify with the array of DCLRefs cast to void*
     return (*localPort)->Notify(
         localPort,
         kFWNuDCLModifyNotification,  // For content/range updates
         dclPtrList.data(),           // Array of pointers to DCLRefs
         count);
}
IOReturn IsochTransmitDCLManager::notifyJumpUpdate(IOFireWireLibLocalIsochPortRef localPort, NuDCLRef* dclRefPtr) {
     if (!localPort || !dclRefPtr || !*dclRefPtr) return kIOReturnBadArgument;
     return (*localPort)->Notify(localPort, kFWNuDCLModifyJumpNotification, (void**)dclRefPtr, 1);
}


} // namespace Isoch
} // namespace FWA



=== src/Isoch/core/IsochTransmitBufferManager.cpp ===
#include "Isoch/core/IsochTransmitBufferManager.hpp"
#include "Isoch/core/TransmitterTypes.hpp" // Include for kTransmitCIPHeaderSize and kTransmitIsochHeaderSize constants
#include <mach/mach.h>
#include <cstring> // For bzero

namespace FWA {
namespace Isoch {

// Constants from TransmitterTypes.hpp are now used
constexpr size_t kTimestampSize = 4;

IsochTransmitBufferManager::IsochTransmitBufferManager(std::shared_ptr<spdlog::logger> logger)
    : logger_(std::move(logger)) {
    if (logger_) logger_->debug("IsochTransmitBufferManager created");
}

IsochTransmitBufferManager::~IsochTransmitBufferManager() {
    // Acquire lock here before calling cleanup
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup();
    if (logger_) logger_->debug("IsochTransmitBufferManager destroyed");
}

void IsochTransmitBufferManager::cleanup() noexcept {
    // NOTE: This function now assumes the caller holds the mutex_ lock.
    if (mainBuffer_) {
        vm_deallocate(mach_task_self(), reinterpret_cast<vm_address_t>(mainBuffer_), totalBufferSize_);
        mainBuffer_ = nullptr;
        clientAudioArea_ = nullptr;
        isochHeaderArea_ = nullptr;
        cipHeaderArea_ = nullptr;
        timestampArea_ = nullptr;
        totalBufferSize_ = 0;
        bufferRange_ = {};
        if (logger_) logger_->debug("IsochTransmitBufferManager::cleanup: Released buffer");
    }
}

void IsochTransmitBufferManager::calculateBufferLayout() {
    totalPackets_ = config_.numGroups * config_.packetsPerGroup;

    // --- MODIFICATION START ---
    // Explicitly set audio payload size. For AM824 Stereo, DBS=2 (8 bytes/frame).
    // Assuming 8 frames per packet for a 64-byte payload, consistent with receiver/legacy.
    // This calculation might become dynamic based on config_.sampleRate and format later.
    const size_t framesPerPacket = 8; // Based on common practice / legacy UniversalTransmitter
    const size_t bytesPerFrameStereoAM824 = 8; // 2 channels * 4 bytes/sample (incl. label)
    audioPayloadSizePerPacket_ = framesPerPacket * bytesPerFrameStereoAM824; // Should be 64 bytes

    if (logger_) {
         logger_->debug("Buffer layout calculated for SampleRate={:.1f}Hz", config_.sampleRate);
         logger_->debug("  Assumed FramesPerPacket={}, BytesPerFrame={}, Resulting PayloadSize={}",
                        framesPerPacket, bytesPerFrameStereoAM824, audioPayloadSizePerPacket_);
    }
     // --- MODIFICATION END ---

    // --- Sizes calculation (NO CHANGE needed here, uses config/constants) ---
    size_t clientDataSize = config_.clientBufferSize;
    size_t cipHeadersSize = totalPackets_ * kTransmitCIPHeaderSize;
    size_t isochHeadersSize = totalPackets_ * kTransmitIsochHeaderSize; // Template only
    size_t timestampsSize = config_.numGroups * kTimestampSize; // Only need one per group/segment completion
    // --- End Sizes calculation ---

    // Align each section
    clientBufferSize_aligned_ = (clientDataSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    cipHeaderTotalSize_aligned_ = (cipHeadersSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    isochHeaderTotalSize_aligned_ = (isochHeadersSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
    timestampTotalSize_aligned_ = (timestampsSize + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

    totalBufferSize_ = clientBufferSize_aligned_ + cipHeaderTotalSize_aligned_ + isochHeaderTotalSize_aligned_ + timestampTotalSize_aligned_;

    if (logger_) {
        logger_->debug("Buffer layout calculated:");
        logger_->debug("  Total packets: {}", totalPackets_);
        logger_->debug("  Audio payload per packet: {} bytes", audioPayloadSizePerPacket_);
        logger_->debug("  Client buffer: {} bytes (aligned: {})", clientDataSize, clientBufferSize_aligned_);
        logger_->debug("  CIP headers: {} bytes (aligned: {})", cipHeadersSize, cipHeaderTotalSize_aligned_);
        logger_->debug("  Isoch headers: {} bytes (aligned: {})", isochHeadersSize, isochHeaderTotalSize_aligned_);
        logger_->debug("  Timestamps: {} bytes (aligned: {})", timestampsSize, timestampTotalSize_aligned_);
        logger_->debug("  Total buffer size: {} bytes", totalBufferSize_);
    }
}

std::expected<void, IOKitError> IsochTransmitBufferManager::setupBuffers(const TransmitterConfig& config) {
    std::lock_guard<std::mutex> lock(mutex_);
    cleanup(); // Clean up previous if any
    config_ = config;

    if (config_.numGroups == 0 || config_.packetsPerGroup == 0 || config_.clientBufferSize == 0) {
        if (logger_) logger_->error("IsochTransmitBufferManager: Invalid config (zeros)");
        return std::unexpected(IOKitError::BadArgument);
    }

    calculateBufferLayout();

    vm_address_t buffer = 0;
    kern_return_t result = vm_allocate(mach_task_self(), &buffer, totalBufferSize_, VM_FLAGS_ANYWHERE);
    if (result != KERN_SUCCESS) {
        if (logger_) logger_->error("IsochTransmitBufferManager: vm_allocate failed: {}", result);
        return std::unexpected(IOKitError::NoMemory);
    }

    mainBuffer_ = reinterpret_cast<uint8_t*>(buffer);
    bzero(mainBuffer_, totalBufferSize_);

    // Assign pointers based on layout
    // clientAudioArea_ = mainBuffer_;
    // cipHeaderArea_ = clientAudioArea_ + clientBufferSize_aligned_;
    // isochHeaderArea_ = cipHeaderArea_ + cipHeaderTotalSize_aligned_;
    // timestampArea_ = reinterpret_cast<uint32_t*>(isochHeaderArea_ + isochHeaderTotalSize_aligned_);

    // SANITY CHECKS
    clientAudioArea_ = mainBuffer_;
    cipHeaderArea_   = clientAudioArea_ + clientBufferSize_aligned_;
    assert(reinterpret_cast<uintptr_t>(cipHeaderArea_) % 16 == 0); // Ensure CIP area is 16-byte aligned

    isochHeaderArea_ = cipHeaderArea_ + cipHeaderTotalSize_aligned_;
    assert(reinterpret_cast<uintptr_t>(isochHeaderArea_) % 16 == 0); // Ensure Isoch header area is 16-byte aligned

    timestampArea_   = reinterpret_cast<uint32_t*>(isochHeaderArea_ + isochHeaderTotalSize_aligned_);
    assert(reinterpret_cast<uintptr_t>(timestampArea_) % sizeof(uint32_t) == 0); // Ensure Timestamp area is 4-byte aligned

    bufferRange_.address = reinterpret_cast<IOVirtualAddress>(mainBuffer_);
    bufferRange_.length = totalBufferSize_;

    if (logger_) {
        logger_->info("IsochTransmitBufferManager::setupBuffers: Allocated buffer at {:p} size {}", (void*)mainBuffer_, totalBufferSize_);
        logger_->debug("  Client audio area: {:p}", (void*)clientAudioArea_);
        logger_->debug("  CIP header area: {:p}", (void*)cipHeaderArea_);
        logger_->debug("  Isoch header area: {:p}", (void*)isochHeaderArea_);
        logger_->debug("  Timestamp area: {:p}", (void*)timestampArea_);
    }

    return {};
}

// Implement Getters (with basic checks)
std::expected<uint8_t*, IOKitError> IsochTransmitBufferManager::getPacketIsochHeaderPtr(uint32_t g, uint32_t p) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups || p >= config_.packetsPerGroup) {
        return std::unexpected(IOKitError::BadArgument);
    }
    size_t offset = (g * config_.packetsPerGroup + p) * kTransmitIsochHeaderSize;
    return isochHeaderArea_ + offset;
}

std::expected<uint8_t*, IOKitError> IsochTransmitBufferManager::getPacketCIPHeaderPtr(uint32_t g, uint32_t p) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups || p >= config_.packetsPerGroup) {
        return std::unexpected(IOKitError::BadArgument);
    }
    size_t offset = (g * config_.packetsPerGroup + p) * kTransmitCIPHeaderSize;
    return cipHeaderArea_ + offset;
}

std::expected<uint32_t*, IOKitError> IsochTransmitBufferManager::getGroupTimestampPtr(uint32_t g) const {
    std::lock_guard<std::mutex> lock(mutex_);
    if (!mainBuffer_ || g >= config_.numGroups) {
        return std::unexpected(IOKitError::BadArgument);
    }
    return timestampArea_ + g;
}

uint8_t* IsochTransmitBufferManager::getClientAudioBufferPtr() const { 
    return clientAudioArea_; 
}

size_t IsochTransmitBufferManager::getClientAudioBufferSize() const { 
    return config_.clientBufferSize;  // Return requested size
}

size_t IsochTransmitBufferManager::getAudioPayloadSizePerPacket() const { 
    return audioPayloadSizePerPacket_; 
}

const IOVirtualRange& IsochTransmitBufferManager::getBufferRange() const { 
    return bufferRange_; 
}

size_t IsochTransmitBufferManager::getTotalBufferSize() const { 
    return totalBufferSize_; 
}

} // namespace Isoch
} // namespace FWA


=== src/Driver/FWADriverHandler.cpp ===
#include "FWADriverHandler.hpp"
#include <os/log.h>
#include <sys/mman.h>   // For mmap, munmap, shm_open, shm_unlink
#include <fcntl.h>      // For O_RDWR
#include <unistd.h>     // For close
#include <stdexcept>
#include <cerrno>
#include <cstring>

constexpr const char* LogPrefix = "FWADriverASPL: ";

FWADriverHandler::FWADriverHandler() {
    localOverrunCounter_ = 0;
}

FWADriverHandler::~FWADriverHandler() {
    TeardownSharedMemory();
}

bool FWADriverHandler::SetupSharedMemory(const std::string& shmName) {
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: Setting up shared memory '%s'", LogPrefix, shmName.c_str());
    if (shmPtr_) {
        os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: Shared memory already set up.", LogPrefix);
        return true;
    }
    shmFd_ = shm_open(shmName.c_str(), O_RDWR, 0);
    if (shmFd_ == -1) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: shm_open failed for '%s': %{errno}d", LogPrefix, shmName.c_str(), errno);
        return false;
    }
    shmSize_ = sizeof(RTShmRing::SharedRingBuffer_POD);
    shmPtr_ = mmap(nullptr, shmSize_, PROT_READ | PROT_WRITE, MAP_SHARED, shmFd_, 0);
    if (shmPtr_ == MAP_FAILED) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: mmap failed: %{errno}d", LogPrefix, errno);
        close(shmFd_);
        shmFd_ = -1;
        shmPtr_ = nullptr;
        return false;
    }
    if (mlock(shmPtr_, shmSize_) != 0) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: WARNING - mlock failed: %{errno}d. Real-time performance may suffer.", LogPrefix, errno);
    }
    os_log_info(OS_LOG_DEFAULT, "%sFWADriverHandler: Hinting kernel to prefetch pages (MADV_WILLNEED).", LogPrefix);
    if (madvise(shmPtr_, shmSize_, MADV_WILLNEED) != 0) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: WARNING - madvise(MADV_WILLNEED) failed: %{errno}d", LogPrefix, errno);
        // This is just a hint, so failure isn't critical, just log it.
    }
    RTShmRing::SharedRingBuffer_POD* sharedRegion = static_cast<RTShmRing::SharedRingBuffer_POD*>(shmPtr_);
    controlBlock_ = &(sharedRegion->control);
    ringBuffer_ = sharedRegion->ring;
    if (controlBlock_->abiVersion != kShmVersion || controlBlock_->capacity != kRingCapacityPow2) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: ERROR - Shared memory header mismatch (abiVersion: %u, capacity: %u). Tearing down.",
            LogPrefix, controlBlock_->abiVersion, controlBlock_->capacity);
        TeardownSharedMemory();
        return false;
    }
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: Shared memory setup successful (Capacity: %u, ABI: %u).", LogPrefix, controlBlock_->capacity, controlBlock_->abiVersion);
    return true;
}

void FWADriverHandler::TeardownSharedMemory() {
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: Tearing down shared memory.", LogPrefix);
    if (shmPtr_ != nullptr) {
        if (munlock(shmPtr_, shmSize_) != 0) {
            os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: WARNING - munlock failed: %{errno}d", LogPrefix, errno);
        }
        if (munmap(shmPtr_, shmSize_) != 0) {
            os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: munmap failed: %{errno}d", LogPrefix, errno);
        }
        shmPtr_ = nullptr;
    }
    if (shmFd_ != -1) {
        close(shmFd_);
        shmFd_ = -1;
    }
    controlBlock_ = nullptr;
    ringBuffer_ = nullptr;
    shmSize_ = 0;
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: Shared memory teardown complete.", LogPrefix);
}

bool FWADriverHandler::PushToSharedMemory(const AudioBufferList* src, const AudioTimeStamp& ts, uint32_t frames, uint32_t bytesPerFrame) {
    if (!controlBlock_ || !ringBuffer_) return false;

    // ----------------------------------------------
    // ➊ if ring full *and* streams not yet active →
    //    advance rd one slot (overwrite oldest)
    // ----------------------------------------------
    if (controlBlock_->streamActive == 0) {
        auto wr = RTShmRing::WriteIndexProxy(*controlBlock_).load(std::memory_order_relaxed);
        auto rd = RTShmRing::ReadIndexProxy(*controlBlock_).load(std::memory_order_relaxed);
        if (wr - rd >= controlBlock_->capacity) {
            // Drop the oldest chunk to make room
            RTShmRing::ReadIndexProxy(*controlBlock_)
                .store(rd + 1, std::memory_order_release);
        }
    }

    bool success = RTShmRing::push(*controlBlock_, ringBuffer_, src, ts, frames, bytesPerFrame);
    
    // Log only after streams are active
    if (!success && controlBlock_->streamActive) {
        auto wr = RTShmRing::WriteIndexProxy(*controlBlock_).load(std::memory_order_relaxed);
        auto rd = RTShmRing::ReadIndexProxy(*controlBlock_).load(std::memory_order_relaxed);
        os_log_error(OS_LOG_DEFAULT,
            "%sPUSH FAIL  wr=%llu rd=%llu used=%llu  frames=%u bytesPerFrame=%u",
            LogPrefix, wr, rd, wr-rd, frames, bytesPerFrame);
        
        localOverrunCounter_++;
        if ((localOverrunCounter_ & 0xFF) == 0) {
            os_log_error(OS_LOG_DEFAULT, "%sPushToSharedMemory: Ring buffer OVERRUN! Count: %u", LogPrefix, localOverrunCounter_);
        }
    }
    return success;
}

OSStatus FWADriverHandler::OnStartIO() {
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: OnStartIO called.", LogPrefix);
    if (!controlBlock_ || !ringBuffer_) {
        os_log_error(OS_LOG_DEFAULT, "%sFWADriverHandler: ERROR - Cannot StartIO, shared memory not set up.", LogPrefix);
        return kAudioHardwareUnspecifiedError;
    }
    localOverrunCounter_ = 0;
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: STUB - Assuming Daemon started IO successfully.", LogPrefix);
    return kAudioHardwareNoError;
}

void FWADriverHandler::OnStopIO() {
    os_log(OS_LOG_DEFAULT, "%sFWADriverHandler: OnStopIO called.", LogPrefix);
    // Optionally update shared atomic counters here
}



